# Kubernetes

## 배경

컨테이너 기반의 환경은 배포에 장점이 있고 마이크로 서비스 아키텍쳐 구조에 잘 맞아들어가는 듯 싶지만, 컨테이너가 약간 빠르다는 장점은 있지만, 가상 머신으로도 충분히 패키징이 가능하고, 로컬의 개발환경을 동기화 시키는 장점은 vagrant로도 충분하다는 생각을 가지고 있다.

그리고 결정적으로 도커 컨테이너를 운용하기 위한 컨테이너 관리 환경이 성숙하지 못했다.

그런데, 마이크로 서비스 아키텍쳐가 단순 개념에서 부터 점점 더 발전하기 시작하였고, 또한 서비스가 작아지면서, 1~2 코어로도 운영할 수 있는 작은 서비스들이 다수 등장하게 되었고 이런 작은 서비스는 VM환경으로 운영하기에는 낭비가 너무 심하다.

컨테이너 기반의 환경이 실질적으로 적용될만하다는 것으로 판단하였고, 다시 컨테이너 환경에 대해서 살펴보기 시작하였다.

### 컨테이너 운영환경

쿠버네티스가 제공하는 컨테이너 운영환경에서 컨테이너는 가장 대표적인 예로는 도커가 있다. 단순히 도커 컨테이너를 하드웨어나 VM에 배포하면 사용하면 되지 왜 컨테이너 운영환경이 필요한가?
-> VM이나 하드웨어의 수가 만하지고 컨테이너의 수가 많아지면, 이 컨테이너를 어디에 배포해야 하는지에 대한 결정이 필요하다.
16CPU, 32GB 메모리 머신들에 컨테이너를 배포할 때 컨테이너 사이즈가 2 CPU, 3 CPU, 8 CPU 등 다양할 수 있기 때문에, 자원을 최대한 최적으로 사용하기 위해서 적절한 위치에 배포해야 하고, 애플리케이션 특성들에 따라서, 같은 물리 서버에 배포가 되어야 하거나 또는 가용성을 위해서 일부러 다른 물리서버에 배포되어야 하는 일이 있다. 이렇게 컨테이너를 적절한 서버에 배포해주는 역활을 스케쥴링이라고 한다.
이러한 스케쥴링 뿐만이 아니라 컨테이너가 정상적으로 작동하고 있는지 체크하고 문제가 있으면 재기동등을 해주고, 모니터링, 삭제관리 등 컨테이너에 대한 종합적인 관리를 해주는 환경이 필요한데, 이를 컨테이너 운영환경이라고 한다.

### 쿠버네티스란?

컨테이너 운영환경 중 가장 널리 사용되는 솔루션이 쿠버네티스(Kubernetes, 약어로 k8s)
구글은 내부 서비스를 클라우드 환경에서 운영하고 있었으며, 내부 컨테이너 서비스를 오픈소스화 한것이 쿠버네티스이다.
GO 언어로 구현이 되었으며, 특히 재미있는 것은 벤더나 플랫폼에 종속되지 않기 때문에, 대부분의 퍼블릭 클라우드 등에 사용이 가능하고 오픈 스택과 같은 프라이빗 클라우드 구축 환경이나 또는 베어메탈에도 배포가 가능하다.

## Master and Node

클러스터의 구조를 이해해야 한다.
마스터는 클러스터 전체를 관리하는 컨트롤러로
노드는 컨테이너가 배포되는 머신(가상머신이나 물리적인 서버머신)

## Object

가장 기본적인 구성단위가 되는 기본 오브젝트(Basic object)와 이 기본 오브젝트를 생성하고 관리하는 추가적인 기능을 가진 컨트롤러(Controller)로 이루어진다. 그리고 이러한 오브젝트의 스펙(설정) 이외에 추가정보인 메타 정보들로 구성이 된다고 보면 된다.

### Object Spec

오브젝트들은 모두 오브젝트의 특성(설정정보)를 기술한 Object Spec으로 정의가 되고, 커맨드 라인을 통해서 오브젝트 생성시 인자로 전달하여 정의를 하거나 또는 yaml 또는 json파일로 스펙을 정의할 수 있다.

### Basic Object

쿠버네티스에 의해서 배포 및 관리되는 가장 기본적인 오브젝트는 컨테이너화되어 배포되는 애플리케이션의 워크로드를 기술하는 오브젝트로 Pod, Service, Volume, Namespace 4가지가 있다.

#### 1. Pod

쿠버네티스에서 가장 기본적인 배포 단위로, 컨테이너를 포함하는 단위이다.
쿠버네티스의 특징 중 하나는 컨테이너를 개별적으로 하나씩 배포하는 것이 아니라 Pod 이라는 단위로 배포하는데, Pod는 하나 이상의 컨테이너를 포함한다.

아래는 간단한 Pod을 정의한 Object Spec이다.

```
apiVersion: v1
kind: Pod
metadata:
name: nginx
spec:
containers:
name: nginx
	image: nginx:1.7.9
	ports:
containerPort: 8090
```
apiVersion은 이 스크립트를 실행하기 위한 쿠버네티스 API 버전이다. 보통 v1을 사용한다.
kind에는 리소스의 종류를 정의하는데, Pod를 정의하려고 하기 때문에, Pod이라고 넣는다.
metadata에는 이 리소스의 각종 메타 데이터를 넣는데, 라벨이나 리소스의 이름등 각종 메타데이터를 넣는다.
spec 부분에 리소스에 대한 상세한 스펙을 정의한다.
Pod은 컨테이너를 가지고 있기 때문에, container를 정의한다. 이름은 nginx로 하고 도커 이미지 nginx:1.7.9를 사용하고, 컨테이너 포트 8090을 오픈한다.

Pod안에 한개 이상의 컨테이너를 가지고 있을 수 있다고 했는데 왜 개별적으로 하나씩 컨테이너를 배포하지 않고 여러개의 컨테이너를 Pod 단위로 묶어서 배포하는 것인가?

Pod은 다음과 같은 매우 재미있는 특징을 갖는다.

Pod 내의 컨테이너는 IP와 Port를 공유한다.
두 개의 컨테이너가 하나의 Pod를 통해서 배포되었을때, localhost를 통해서 통신이 가능하다.
예를들어 컨테이너 A까 8080, 컨테이너 B가 7001로 배포가 되었을 때, B에서 A를 호출할때는 localhost:8080으로 호출하면 되고, 반대로 A에서 B를 호출할때는 localhost:7001로 호출하면 된다.
Pod 내에 배포된 컨테이너간에는 디스크 볼륨을 공유할 수 있다.
근래 애플리케이션들은 실행할 때 애플리케이션만 올라가는 것이 아니라 Reverse proxy, 로그 수집기 등 다양한 주변 솔루션이 같이 배포가 되는 경우가 많고, 특히 로그 수집기의 경우에는 애플리케이션 로그 파일을 읽어서 수집한다. 애플리케이션(Tomcat, nodejs)와 로그 수집기를 다른 컨테이너로 배포할 경우, 일반적인 경우에는 컨테이너에 의해서 파일시스템이 분리되기 때문에, 로그 수집기가 애플리케이션이 배포된 컨테이너의 로그파일을 읽는 것이 불가능 하지만, 쿠버네티스의 경우 하나의 Pods 내에서는 컨테이너들끼리 볼륨을 공유할 수 있기 때문에 다른 컨테이너의 파일을 읽어올 수 있다.

#### 2. Volume

Pod이 기동할 때 디폴트로, 컨테이너마다 로컬 디스크를 생성해서 기동되는데, 이 로컬 디스크의 경우에는 영구적이지 못하다. 즉, 컨테이너가 리스타트 되거나 새로 배포될때 마다 로컬 디스크는 Pod 설정에 따라서 새롭게 정의되서 배포되기 때문에, 디스크에 기록된 내용이 유실된다.
데이터베이스와 같이 영구적으로 파일을 저장해야 하는 경우에는 컨테이너 리스타트에 상관 없이 파일을 영속적으로 저장해야 하는데, 이러한 형태의 스토리지를 볼륨이라고 한다.
볼륨은 컨테이너의 외장 디스크로 생각하면 된다. Pod이 기동할 때 컨테이너에 마운트해서 사용한다.

앞에서 언급한것과 같이 쿠버네티스의 볼륨은 Pod내의 컨테이너간의 공유가 가능하다.

쿠버네티스는 다양한 외장 디스크를 추상화된 형태로 제공한다. iSCSI나 NFS와 같은 온프로미스 기반의 일반적인 외장 스토리지 이외에도, 클라우드의 외장 스토리지인 AWS EBS, Google PD에서부터 github, glusterfs와 같은 다양한 오픈소스 기반의 외장 스토리지나 스토리지 서비스를 지원하여, 스토리지 아키텍처 설게에 다양한 옵션을 제공한다.

#### 3. Service

Pod와 볼륨을 이용하여, 컨테이너들을 정의한 후에, Pod를 서비스로 제공할 때, 일반적인 분산환경에서는 하나의 Pod로 서비스 하는 경우는 드물고, 여러개의 Pod를 서비스하면서, 이를 로드밸런서를 이용해서 하나의 IP와 포트로 묶어서 서비스를 제공한다.

Pod의 경우에는 동적으로 생성이 되고, 장애가 생기면 자동으로 리스타트 되면서 그 IP가 바뀌기 때문에, 로드밸런서에서 Pod의 목록을 지정할 때는 IP주소를 이용하는 것은 어렵다. 또한 오토스케일링으로 인하여 Pod이 동적으로 추가 또는 삭제되기 때문에, 이렇게 추가/삭제된 Pod 목록을 로드밸런서가 유연하게 선택해 줘야 한다.
그래서 사용하는 것이 라벨(label)과 라벨 셀렉터(label selector)라는 개념이다.

서비스를 정의할 때, 어떤 Pod를 서비스로 묶을 것인지를 정의하는데, 이를 라벨 셀렉터라고 한다. 각 Pod를 생성할때 메타데이타 정보 부분에 라벨을 정의할 수 있다. 서비스는 라벨 셀렉터에서 특정 라벨을 가지고 있는 Pod만 선택하여 서비스에 묶게 된다.

Object Spec

kind: Service
…
spec:
	selector:
		app:myapp
	ports:
protocol: TCP
	port: 80
	targetPort: 9376

spec부분에서 서비스에 대한 스펙을 정의한다.
selector에서 라벨이 app:myapp인 Pod만을 선택해서 서비스에서 서비스를 제공하게 하고
포트는 TCP를 이용하되, 서비스는 80 포트로 서비스를 하되, 서비스의 80포트의 요청을 컨테이너의 9376포트로 연결해서 서비스를 제공한다.

#### 4. Name Space

한 쿠버네티스 클러스터내의 논리적인 분리단위라고 보면 된다.
Pod, Service 등은 네임 스페이스 별로 생성이나 관리가 될 수 있고, 사용자의 권한 역시 이 네임 스페이스 별로 나눠서 부여할 수 있다.
즉, 하나의 클러스터 내에, 개발/운영/테스트 환경이 있을때, 클러스터를 개발/운영/테스트 3개의 네임 스페이스로 나눠서 운영할 수 있다.

할수 있는 일은

* 사용자별로 네임스페이스별 접근 권한을 다르게 운영할 수 있다.
* 네임스페이스별로 리소스의 쿼타(할당량)을 지정할 수 있다. 개발계에는 CPU 100, 운영에게는 CPU 400 식으로, 사용 가능한 리소스의 수를 지정할 수 있다.
* 네임스페이스별로 리소스를 나눠서 관리할 수 있다.(Pod, Service 등)


주의할점은 네임스페이스는 논리적인 분리 단위이지 물리적이나 기타 장치를 통해서 환경을 분리한것이 아니다. 다른 네임스페이스간의 Pod이라도 통신은 가능하다.
물론 네트워크 정책을 이용하여, 네임스페이스간의 통신을 막을 수 있지만 높은 수준의 분리 정책을 원하는 경우에는 쿠버네티스 클러스터 자체를 분리하는 것을 권장한다.

Cluster: mycluster
	Namespace: billing
	Namespace: commerce

#### 5. Label

라벨은 쿠버네티스의 리소스를 선택하는데 사용이 된다. 각 리소스는 라벨을 가질 수 있고, 라벨 검색 조건에 따라서 특정 라벨을 가지고 있는 리소스만을 선택할 수 있다.
이렇게 라벨을 선택하여 특정 리소스만 배포하거나, 업데이트 할 수 있고 또는 라벨로 선택된 리소스만 Service에 연결하거나 특정 라벨로 선택된 리소스에만 네트워크 접근 권한을 부여하는 등의 행위를 할 수 있다.
라벨은 metadata 섹션에 키/값 쌍으로 정의가 가능하며, 하나의 리소스에는 하나의 라벨이 아니라 여러 라벨을 동시에 적용할 수 있다.

셀렉터를 사용하는 방법은 오브젝트 스펙에서 selector라고 정의하고 라벨 조건을 적어놓으면 된다.
Equality based selector와 Set based selector가 있다.
Equality based selector는 같냐, 다르냐의 조건을 이용하여 리소스를 선택함. (= or !=)
set based selector는 집합의 개념을 사용한다.
	environment in (production, qa)는 environment가 production 또는 qa인 경우
	tier notin (frontend, backend)는 environment가 frontend도 아니고 backend도 아닌 리소스를 선택하는 방법

#### 6. controller

위 4개의 기본 오브텍트로, 애플리케이션을 설정하고 배포하는 것이 가능한데, 이를 조금 더 편리하게 관리하기 위해서 쿠버네티스는 컨트롤러라는 개념을 사용한다.
컨트롤러는 기본 오브젝트들을 생성하고 이를 관리하는 역활을 해준다. 컨트롤러는

##### 6.1 종류

* Replication Controller(aka RC)
  * Pod를 관리해주는 역활
  * 지정된 숫자로 Pod을 기동시키고, 관리하는 역활
  * 3가지 파트로 구성
    * Replica의 수
      * RC에 의해서 관리되는 Pod의 수, 그 숫자만큼 Pod의 수를 유지하도록 한다.
    * Pod Selector
      * 라벨을 기반으로 하여, RC가 관리한 Pod을 가지고 오는데 사용
    * Pod Template
      * Pod를 추가로 기동할 떄 그러면 어떻게 Pod을 만들지 Pod에 대한 정보(도커 이미지, 포트 라벨 등)에 대한 정보를 여기서 정의
* Replication Set
  * Replication Controller의 새 버전으로 생각하면 된다.
  * 큰 차이 X -> Replication Controller는 Equality 기반 Selector를 이용하는데 반해, ReplicaSet은 Set 기반의 Selector를 사용
* DaemonSet
* Job
* StatefulSet
* Deployment
  * Replication Controller와 ReplicaSet의 좀더 상위 추상화 개념이다. 실재 운영에서는 RC와 RcplicaSet를 바로 사용하는 것보다, 좀 더 추상화된 Deployment를 사용

## 쿠버네티스 내부 서비스끼리 연결

쿠버네티스 내부에 다른 pod으로 연결이 가능한것은 serviceName.nameSpace로 쿠버내 자체 dns가 있어서 그런듯 하다.

http://{service_name}.{namespace} 로 연결하면 된다.
Ex. http://dev-account.dev-service/v1/accounts

* service_name은 helm에서 쿠버를 올릴때 만들어지는데, 현재 설정은 `{profile}-{name}`이다.


## 참고

조대협의 블로그(https://bcho.tistory.com/1255)
