# JPA Entity Dto

> MVC기반에서 Model의 역활 - 영속성을 띈 Entity

MVC기반으로 개발할 때, 특히 MVC 기반의 REST API서버를 만들때는 View영역과 Repository영역에서 사용되는 dataModel을 분리해서 사용하는게 일반적이다.

영속성 영역의 데이터를 관리하는 클래스는 보통 Repository클래스로 지칭하고 `@Repository` 어노테이션을 붙여 그 역활을 부여.
Repository에 있는 Entity 클래스들은 대부분 DB의 테이블 스키마와 1:1 매칭된 형태의 구조로 정의된다.
특히, JPA를 사용하는 경우는 `Entity class = DB Table` 구조가 된다.

Student이라는 영속성을 띈 모델을 설계하고, Entity 클래스로 정의하고, DB의 테이블로 생성하면,
Student 클래스는 모델의 설계가 바뀌지 않는 이상, 바뀌지 않는다.
MVC 관점에서 Model의 역활을 하는 클래스들이다.

* API 예시
1. 학생등록 API (POST)
   1. input: 학생이름, 성별, 생년월일, 전화번호, 비밀번호, 이메일, 주소 등..
   2. output: 필요없음(성공여부 정도)
2. 학생 이메일정보변경 API (PUT)
   1. input: 학번, 원래 이메일, 변경후 이메일, 비밀번호
   2. output: 필요없음(성공여부 정도)
3. 내 정보조회 API (GET)
   1. input: 학번
   2. output: 학생명, 이메일

> 이 Entity클래스들이 View영역까지 넘어가서 사용하는것이 맞을까?

사용을 해도 프로그래밍적으로는 문제가 없다! 하지만.. MVC를 지향하는 Spring 프레임워크를 쓰는 개발환겨에서는 좋은 구조라고 할 수는 없다.
1. View에서 표현하는 속성값들은 요청에 따라 계속 달라질 수 있는데, 그 때마다 Entity의 속성값들이 변하게 되면 학생이라는 영속성 모델을 표현한 Students 클래스의 순수성이 모호해지게 된다.
   1. 예를 들어, 학생 이메일을 변경하는 API의 경우
      1. View에서 요청시 보내는 항목에는 원래의 이메일과 변경 이메일이 필요한데, Entity 클래스의 입장에서는 둘다 동일한 email속성이다.
      2. View에서 요청처리를 위해서 `afterEmail` 속성값을 추가해서 쓰게 되면 학생 Entity는 동일한 성격의 이메일에 대해서 두개의 속성값을 가지게 된다.
      3. 이런 부분들은 로직을 처리함에 있어 문제는 되지 않는다.
      4. 하지만, View의 요청에 따라 항목들이 계속 추가되어야 하는 경우, Entity는 그 순수성을 읽게 되고, 영속성 모델(테이블)과의 관계성도 모호해지게 되면서 MVC기반의 설계 자체가 흔들리게 된다.
2. 영역간 불필요한 속성값들의 전달로 불필요한 방어 및 체크로직이 생겨날 수 있고 API서비스의 경우, 명세가 달라지는 큰 이슈가 발생한다.
   1. 위의 API에서 2번과 3번은 각각 요청과 응답객체에서 불필요한 속성값들이 포함되게 된다.
   2. 학생 이메일 정보변경의 경우, 변경전, 변경후 이메일 속성만 요청값으로 필요한데 학생 Entity클래스를 전체를 쓰게 된다.
   3. 내 정보조회의 경우, 응답항목으로 학생명과 이메일주소만 필요한데 학생 Entity의 모든 속성정보가 응답항목으로 넘어오게 된다.
   4. 이 이슈는 어플리케이션의 View영역이 실제 화면인 경우에는 단순히 불필요한 속성값의 전달이 이슈-화면에서 사용하지 않으면 문제는 없다.-이겠지만 어플리케이션이 API 서버라면 꽤 심각한 이슈가 생긴다.
   5. API 애플리케이션에서는 응답전문자체가 View를 의미하기 때문에 내정보조회 API의 응답객체를 Students로 사용하게 되면 API명세자체가 달라지게 된다.

## 참고

* https://yonguri.tistory.com/69
