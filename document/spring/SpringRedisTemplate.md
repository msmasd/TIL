# SpringRedisTemplate

3.1 버전부터 스프링 프레임워크는 기존 스프링 애플리케이션에 캐시를 투명하게 추가하도록 지원한다.
트랜잭션 지원과 비슷하게 캐시 추상화도 코드에 영향을 최소화하면서 다양한 캐시 솔루션을 일관성 있게 사용할 수 있게 한다.

## 캐시 추상화 이해하기
추상화는 Java 메서드에 캐싱을 적용함으로써 캐시에 보관된 정보로 메서드의 실행 횟수를 줄여준다.
즉, 대상 메서드가 실행될 때마다 추상화가 해당 메서드가 같은 **인자**로 이미 실행되었는지 확인하는 캐싱 동작을 적용한다. 해당 데이터가 존재한다면 실제 메서드를 실행하지 않고 결과를 반환하고 존재하지 않는다면 메서드를 실행하고 그 결과를 캐싱한 뒤에 사용자에게 반환해서 다음번 호출 시에 사용할 수 있게 한다.
이 방법을 통해 비용이 큰 메서드는 해당 파라미터로는 딱 한번만 실행할 수 있고 다시 메서드를 실행하지 않고도 결과를 재사용할 수 있다.
호출자가 어떤 방해도 받지 않고 캐싱 로직은 투명하게 적용된다.

* 캐싱 선언: 캐시되어야 하는 메서드와 정책을 정한다.
* 캐시 구성: 데이터를 저장하고 읽을 기반 캐시
  * 캐시 추상화는 개발자가 캐시 로직을 작성하지 않아도 되지만 실제 스토어는 제공하는 것은 아니다.

## 선언적인 어노테이션 기반의 캐싱
캐싱 선언으로 추상화가 두가지 Java 어노테이션을 제공한다.

* @Cacheable: 캐시군(cache population)
* @CacheEvict: 캐시 만료(cache eviction)

### @Cacheable 어노테이션
* 캐시를 할 수 있는 메서드를 지정하는데 사용
* 해당 어노테이션을 사용한 메서드는 결과를 캐시에 저장하므로 같은 인자로 뒤이은 호출에는 실제로 메서드를 실행하지 않고 캐시에 저장된 값을 반환한다.

#### 기본키 생성
캐시는 본질적으로 key-value 저장소이므로 캐시된 메서드를 호출할 때마다 해당 키로 변환되어야 한다.
캐시 추상화는 다음 알고리즘에 기반을 둔 keyGenerator를 사용한다.
* 파라미터가 없으면 0을 반환한다.
* 파라미터가 하나만 있으면 해당 인스턴스를 반환한다.
* 파라미터가 둘 이상이면 모든 파라미터의 해시를 계산한 키를 반환한다.

## 참고
* http://blog.naver.com/PostView.nhn?blogId=willygwu2003&logNo=130172611343
* https://blog.outsider.ne.kr/1094
