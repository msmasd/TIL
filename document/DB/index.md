# index

## 1. index tree

인덱스를 생성하는데 b-tree(balanced Tree)를 사용한다.

### 1.1 hashtable을 사용하지 않는 이유

SELECT 질의의 조건에는 등호(<>)연산도 포함이 된다. hashtable을 사용하게 된다면 = 연산이 아닌 등호 연산의 경우에 문제가 발생한다. 동등 연산(=)에 특화된 hashtable은 데이터베이스의 자료구조로 적합하지 않다.

### 1.2 B(alanced-Tree)

#### 1.2.1 용어정리

* branch: 노드 아이템(root와 leaf사이의 모든 모드들)
* root: 최상위 노드
* leaf: 맨 마지막 노드

#### 1.2.2 B-Tree

B-Tree는 최소한 반 이상 차있으며, 가급적 낮은 레벨을 지향하며 완전 균형 트리이다.

차수가 m인 B-Tree는 다음과 같은 기본적인 정의를 만족시키는 균형 잡힌 M-원 트리이다.

* 각 node는 최대 m개, 최소(m/2)개의 서브트리를 가져야 한다.
  * 이 조건에 의해 트리의 각 노드가 적어도 반 이상은 key값으로 채워져 있도록 한다. 따라서 서브트리가 없는 노드가 발생하지 않고 key값이 가능한 효율적으로 서브트리에 분배될 수 있도록 한다.
* Root노드는 최소한 두 개의 서브트리를 가져야 한다(단 트리에 root만 있을 경우 서브트리는 없다.)
  * 이 조건에 의해 tree가 처음부터 분기하도록 한다.
* 모든 leaf노드는 같은 레벨에 있어야 한다.(즉, 모든 leaf노드는 root로부터 같은 거리에 있어야 한다.)
  * 모든 leaf노드가 root로부터 같은 거리에 있으므로 어느 leaf노드를 탐색하든 처리 횟수가 같도록 한다.
* 각 leaf노드의 key값의 개수는 최소 (m/2)-1개, 최대 m-1개이다.

노드의 크기는 디스크 블록의 크기와 같게 조정될 수 있다. 따라서 노드에 저장할 수 있는 데이터의 양은 꽤 큰편.


#### 1.2.3 특징

B-Tree 인덱스는 디스크 I/O를 고려하여 관계형 데이터베이스에서 가장 일반적으로 사용되는 인덱스이다. 이 인덱스도 크기가 커져 보조 기억 장치에 저장되게 되는데 이또한 디스크 I/Ork 발생하게 되는 것이다. 따라서 B-Tree의 깊이를 줄여야 디스크 I/O를 줄일 수 있기 때문에 B-Tree를 사용한다.
Root Block을 기준으로 Branch Block들이 존재하며 Branch block들의 depth는 모두 동일하다. 이것은 Leaf block들이 같은 높이에 위치하도록 유지시켜준다. 즉, 데이터를 가진 block에 탐색 시간을 동일하게 유지하는 효과가 있다.

B-tree의 검색속도는 트리의 깊이에 비례하지만 d의 값은 별로 크지 않다. 왜냐하면 브랜치 블록 노드에 저정하는 key 값의 수를 늘리기 때문이다. 브랜치 블록이 200개이고 깊이가 3인 B-tree에는 200^3인 800만개의 데이터를 저장할 수 있다.

#### 1.2.4 B-Tree와 B+-Tree의 차이

##### 1.2.4.1 B-Tree

key와 관련된 정보(satellite information)를 key를 포함하는 node에 저장한다. 즉 각 노드에 데이터가 저장되는 것이다. 그렇기 때문에 리프 노드를 읽기 전에 원하는 값을 찾을 수 있고 탐색 시간이 탐색 키 수의 로그에 비례한다.

##### 1.2.4.2 B+-Tree

key와 관련된 정보(satellite information)는 모두 leaf node에 저장되고 internal node(branch block)에는 key와 child pointer만 저장한다. 즉, 인덱스 노드와 데이터가 저장된 리프노드가 분리되어 존재한다. 각각의 leaf block들은 sorting되어 있으며 내림차순, 오름차순 두 상황에 대비해 서로 연결되어 있으며(linked list)임의 접근과 순차접근 모두 성능이 우수하다. 그리고 탐색 시에는 항상 루트 노드부터 탐색을 시작한다. 즉, B+-Tree는 기존의 B-Tree에 리프노드 끼리의 연결리스트 구조가 추가된 것이라고 할 수 있다.

## 2. index scan

### 2.1 index Full Scan

1. 수직적 탐색 없이 **인덱스 리프 블록**을 처음부터 끝까지 수평적으로 탐색하는 방식
2. 최적의 인덱스가 없을 때 차선으로 선택
3. 인덱스 선두 컬럼이 조건절에 없으면 Table Full Scan을 고려하나, Table Full Scan보다 I/O를 줄일 수 있거나 정렬된 결과를 쉽게 얻을 수 있을 경우 Index Full Scan 선택
4. index Full Scan은 결과집합이 인덱스 컬럼 순으로 정렬됨으로 Sort Order By 연산을 생략할 목적으로 사용.
5. Sort 연산을 생략함으로써 전체 집합 중 처음 일부만을 빠르게 리턴할 목적으로 Index Full Scan을 선택.
   1. 사용자가 데이터 읽기를 멈추지 않고 끝까지 fetch한다면 Full Table Scan 한것보다 더 많은 I/O를 발생

### 2.2 Index Range Scan

* 인덱스 루트 블록에서 리프 블록까지 수직적으로 탐색한 후에 리프 블록을 필요한 범위만 스캔하는 방식

### 2.3 Index Unique Scan

* 수직적 탐색만으로 데이터를 찾는 스캔 방식
* Unique Index가 존재하는 컬럼은 중복 값이 발생하지 않도록 DBMS가 데이터 정합성을 관리해준다. 따라서 해당 인덱스 키 칼럼을 모두 '='조건으로 검색할 때는 데이터를 한 건 찾는순간 더이상 탐색할 필요가 없다.
* Unique Index라도 범위 조건으로 검색할 때는 Index Range Scan으로 처리된다.

### 2.4 Index Skip Scan

* 선두 컬럼이 조건절에 빠졌어도 인덱스를 활용하는 새로운 스캔방식
* Root 또는 Branch 블록에서 읽은 컬럼 값 정보를 이용해 조건에 부합하는 레코드를 포함할 가능성이 있는 리프 블록만 골라서 액세스 하는 방식
  * 첫번째 리프 블록과 마지막 리프 블록을 항상 방문한다.
  * 후미 조건이 조건절에 들어가야한다.
* 리프 블록에 있는 정보만으로 다음에 방문해야 할 블록을 찾는 방법은 없다. 항상 그 위쪽에 있는 브랜치 블록을 재방문 해서 다음 방문할 리프 블록에 대한 정보를 얻는다.
  * Buffer Pinning 방식을 이용해 Branch버퍼를 Pinning한 채로 리프블록을 방문했다가 다시 Branch블록을 찾는 과정으로 Branch블록을 재방문한다.
* 쿼리 작성자가 조건식을 직접 추가해 주면 Index Skip Scan을 이용하지 않아도 Range Scan으로 빠르게 결과 집합을 보장할수 있다.
  * 단 명시된 값의 종류가 더이상 늘지 않아야 한다.

### 2.5 Index Fast Full Scan

* Index Full Scan보다 빠르다. 인덱스 트리 구조를 무시하고 인덱스 세그먼트 전체를 Multiblock Read 방식으로 스캔하기 때문

### 2.6 Index Range Scan Descending

* Index Range Scan과 동일한 스캔 방식이나 인덱스를 뒤에서부터 앞쪽으로 스캔하기 때문에 내림차순으로 정렬된 결과집합을 얻는다.

### 2.7 Index Join

* Index Join: 한 테이블에 속한 여러 인덱스를 이용해 테이블 엑세스 없이 결과집합을 만들 때 사용하는 인덱스 스캔 방식.
* Hash Join 매카니즘 사용
* 쿼리에 사용된 컬럼들이 인덱스에 모두 포함될 떄만 작동

## 3. 그외 특징

## 3.1 결합 인덱스(Composite Index)

인덱스로 설정하는 필드의 속성이 중요하다. Title, author 이 순서로 인덱스를 설정한다면 title을 search하는 경우, index를 생성한 효과를 볼 수 있지만, author만으로 search하는 경우, index를 생성한 것이 소용이 없어진다. 따라서 SELECT 질의를 어떻게 할 것인가가 인덱스를 어떻게 생성할 것인가에 대해 많은 영향을 끼치게 된다.

* 복합 인덱스를 설정할 때, 두 필드를 복합 인덱스로 설정한다고 하면, 두 필드의 데이터 타입이 합친 것의 총 바이트 3072byte를 넘지 않아야 한다. 그래야 에러가 발생하지 않는다.

## 참조

1. [index full scan](http://wiki.gurubee.net/pages/viewpage.action?pageId=26742990)
2. [B-Tree](http://egloos.zum.com/sweeper/v/896423)
3. [Index의 원리와 종류](https://asfirstalways.tistory.com/339)`
