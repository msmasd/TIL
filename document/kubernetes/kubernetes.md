# kubernetes

구글에서 사용하는 container orchestration이다.

컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성이 있고, 확장가능한 오픈소스 플랫폼이다. 쿠버네티스는 선언적 구성과 자동화를 모두 용이하게 해준다. 쿠버네티스는 크고, 빠르게 성장하는 생태계를 가지고 있다. 쿠버네티스 서비스, 기술 지원 및 도구는 어디서나 쉽게 이용할 수 있다.


## container

### 왜 컨테이너를 사용하는가?

애플리케이션을 배포하는 옛 방식 은 운영 체제의 패키지 관리자를 사용해서 애플리케이션을 호스트에 설치하는 것이었다. 이 방식은 애플리케이션의 실행 파일, 설정, 라이브러리 서로 간의 라이프사이클과 호스트 OS와 얽히게 된다는 단점이 있다. 예측 가능한 롤아웃과 롤백을 위해서 불변의 가상 머신 이미지를 만들 수도 있지만, VM은 너무 크고 이식 가능하지 않다.

새로운 방법 은 하드웨어 가상화가 아닌 운영 체제 수준의 가상화에 기반한 컨테이너를 배포하는 것이다. 이 컨테이너는 서로 격리되고 호스트와도 격리된다. 컨테이너는 컨테이너 자체의 파일시스템을 갖고, 다른 컨테이너의 프로세스를 알 수 없으며, 연산에 필요한 자원을 제한할 수 있다. VM보다 빌드하기 쉬우며, 기반이 되는 인프라스트럭처와 호스트 파일시스템에서 디커플되었기(decoupled) 때문에 클라우드나 OS 배포판 간 이식성이 있다.

컨테이너는 작고 빠르기 때문에, 애플리케이션 각각을 컨테이너 이미지로 패키지할 수 있다. 이렇게 애플리케이션과 이미지를 일대일 관계를 갖도록 하면 컨테이너의 혜택을 만끽할 수 있게 된다. 불변의 컨테이너 이미지는 배포 시점이 아닌 빌드/릴리스 시점에 만들어질 수 있다. 왜냐하면 각각의 애플리케이션은 애플리케이션 스택 외의 나머지 요소와 조합될 필요가 없기 때문이고, 운영 인프라스트럭처 환경에 밀접하게 결합시킬 필요도 없기 때문이다. 컨테이너 이미지를 빌드/릴리스 시점에 생성하게 되면 개발 환경부터 운영 환경까지 일관된 환경을 가져갈 수 있게 된다. 마찬가지로, 컨테이너는 VM보다 훨씬 더 투명해서 모니터링과 관리가 용이하다. 컨테이너의 프로세스 라이프사이클이 수퍼바이저 프로세스에 의해 컨테이너 내에 감추어지지 않고, 인프라스트럭처에 의해 관리될 때 더욱 이는 용이해진다. 컨테이너마다 단일 애플리케이션을 담게되면, 궁극적으로 컨테이너를 관리하는 것이 애플리케이션의 배포를 관리하는 것과 같아진다.