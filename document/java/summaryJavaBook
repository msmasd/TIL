자바 추가 공부내역

JIT Compiler

java 실행시 해당 class를 로드하고, 클래스 파일 검터 후, 지정된 클래스에 있는 main함수 실행

변수는 선언(declare)와 초기화(initialize)가 있다. 그리고 변수는 식별자(identifier)를 통해 프로그램이 각 변수들을 식별한다.
식별자 규칙
1. 대소문자가 구분되며 길이에 제한이 없다
2. 예약어는 사용 불가
3. 숫자로 시작 불가
4. 특수문자는 ‘_’와 ‘$’만 가능

개발자들간의 식별자 컨벤션
1. 클래스 이름의 첫 글자는 항상 대문자, 변수와 메서드는 소문자
2. 자바는 카멜케이스
3. 상수의 이름은 항상 대문자

변수는 기본형과 참조형이 있다

기본형(primitive)는 실제 값을 저장, 참조형은 주소값을 저장

상수는 기본형 변수를 선언 이후 값을 변경할 수 없게 만드는것이며 **final**키워드를 사용한다. 
상수는 1.6버전 이후로부터는 선언시 초기화를 할 필요는 없고 사용하기 전에 하면 된다.

리터럴(literal)
  원래는 12, 123, 3.14, ‘a’와 같은 값들이 ‘상수’인데, 프로그래밍에서는 이미 상수를 ‘값을 한 번 저장하면 변경할 수 없는 저장공간’으로 정의하였기 때문에 이와 구분하기 위해 상수를 다른이름으로 ‘리터럴’으로 사용
즉 리터럴은 상수와 동일한 내용

리터럴 종류

1. 논리형(true, false)
2. 정수형(1, 077, 0xFF, 100L)
3. 실수형(3.14, 1.4f)
4. 문자형(‘a’, ‘1’)
5. 문자열(“abc”, “123”)

실수형에서는 접미사 f(float), d(double)(생략가능)이 존재, 정수형에는 l or L(long)이 존재

배열의 복사는 **System.arraycopy함수**로 처리하기

객체지향이론의 기본 개념은 ‘실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다’ 실제 사물의 속성과 기증을 분석한 다음, 데이터(변수)와 함수로 정의함으로써 실제 세계를 컴퓨터 속에 옮겨 놓은 것과 같은 가상세계를 구현함.

*객체지향이론의 관점*
클래스의 정의: 객체를 정의해 놓은 것
클래스의 용도: 객체를 생성하는데 사용된다.

*프로그래밍적 관점*
클래스: 데이터와 함수의 결합, 사용자정의 타입(user-defined-type)

클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화(instantiate)
어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스(instance)라고 한다.

객체는 속성과 기능으로 이루어져있다.
객체가 가지고 있는 속성과 기능을 그 객체의 멤버(member)라 한다.
여기서 속성은 멤버변수, 기능은 메서드라고 한다.

인스턴스의 생성과 사용
Tv t; // Tv클래스 타입의 참조변수 t를 선언
t = new TV(); // Tv인스턴스를 생성 후 , 생성된 Tv인스턴스의 주소를 t에 저장

클래스의 변수
1. 클래스 변수: 클래스 영역에 선언, 생성은 클래스가 메모리에 올라갈 때
2. 인스턴스 변수: 클래스 영역에 선언, 생성은 인스턴스가 생성되었을 때
3. 지역변수: 클래스 영역 이외의 영역, 변수 선언문이 수행되었을 때

클래스 변수는 static으로 사용되어지고, 모든 인스턴스가 공통된 저장공간을 공유하게 된다. 한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성의 경우, 클래스변수 사용
그리고 클래스 변수는 인스턴스 변수와 다르게, 인스턴스를 생성하지않고도 언제라도 바로 사용할 수 있다.

인스턴스 변수는 인스턴스마다 독립적인 저장공간을 가지므로 서로 다른 값을 가질 수 있다.

자바에서 메서드 호출 시, 매개변수로 지정한 값을 메서드의 메개변수에 복사하여 넘겨준다. 매개변수의 타입이 기본형일 때는 기본형 값이 복사되지만, 참조형이면 인스턴스의 주소가 복사된다. 참조형으로 넘겨지면 값을 읽고, 쓰기까지 가능하다.

클래스 설계
1. 멤버변수 중 모든 인스턴스에 공통적으로 사용해야하는 것에 static사용
2. 클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있다
3. 클래스 메서드는 인스턴스 변수를 사용할 수 없다
4. 1. 인스턴스 멤버는 인스턴스가 반드시 존재해야만 사용할 수 있으므로 클래스 메서드에서 인스턴스 멤버 사용 불가
5. 메서드 내에서 인스턴스 변수를 사용하지 않는다면 static을 붙이는 것을 고려한다.(매개변수로 받아서 처리하면 static사용 좋음)

오버로딩: 한 클래스 내에서 같은 이름의 메서드를 여러개 정의하는 것
장점: 인자가 다른경우에도 함수 이름을 다르게 쓴다면 일일이 다 기억하기 어려운 것을 쉽게 만들어줌

가변인자(variable argument): 매개변수가 동적으로 지정할 수 있게 만들어줌
public void Test(String t1, Object... args)

생성자는 인스턴스가 생성될 때 호출되는 인스턴스 초기화 메서드 이다. 인스턴스 생성 시에 실행되어야 할 작업을 위해서 사용된다.
생성자 역시 메서드처럼 클래스 내에 선언되며, 구조도 메서드와 유사. 리턴값이 없는것이 특징(void)도 사용하지않음
생성자는 오버로딩이 가능(여러 인자에 따라 초기값을 새팅해줄 수 있다)
**연산자 new가 인스턴스를 생성하는 것이지, 생성자가 인스턴스를 생성하지 않는다!!**
단지 생성자는 인스턴스변수들의 초기화에 사용되는 메서드

클래스가 인스턴스를 생성하는 과정(Card c = new Card();)
1. 연산자 new에 의해서 메모리(heap)에 클래스의 인스턴스가 생성
2. 생성자 Card()가 호출되어 수행된다.
3. 연산자 new의 결과로, 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장된다.

자버에서 클래스 내에 생성자가 없을시 기본 생성자를 만들어준다.(만약 다른 생성자가 있다면 만들어주지 않는다)

생성자의 이름으로 클래스이름 대신 this를 사용한다.
한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에만 호출이 가능하다.

this()는 생성자를 호출하는 것이고, this는 인스턴스 자신을 가리키는 참조변수이다. 모든 인스턴스메서드에서 지역변수로 숨겨진 채로 존재(this. 를 통해 인스턴스 멤버에 접근 가능)

멤버변수(클래스변수, 인스턴스변수)와 배열의 초기화는 선택적이지만, 지역변수의 초기화는 필수적이다.

참조형변수의 디폴트값은 null 나머지는 0

클래스 관계
1. 포함(composite)은 클래스 멤버변수에 다른 클래스 인스턴스를 가지는 것

자바는 단일상속만 가능

Object클래스는 모든 클래스의 조상
여기에서 toString, Equals가 정의된 것

오버라이딩은 조상 클래스로 부터 상속받은 메서드의 내용을 변경하는 것
조건은 이름, 매개변수, 반환타입이 다 같아야한다

조상클래스의 메서드를 자손 클래스에서 오버라이딩할 때
1. 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경 불가
2. 예외는 조상 클래스의 매서드보다 많이 선언 불가
3. 인스턴스메서드를 static메서드로 또는 그 반대로 변경 불가

super는 자손 클래스엣 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수.
super에서는 인스턴스변수만 사용할 수 있기 때문에 static메서드에서는 사용 불가.

super()는 조상 클래스의 생성자.

다형성까지 진행

