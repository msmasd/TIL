자바 추가 공부내역

JIT Compiler

java 실행시 해당 class를 로드하고, 클래스 파일 검터 후, 지정된 클래스에 있는 main함수 실행

변수는 선언(declare)와 초기화(initialize)가 있다. 그리고 변수는 식별자(identifier)를 통해 프로그램이 각 변수들을 식별한다.
식별자 규칙
1. 대소문자가 구분되며 길이에 제한이 없다
2. 예약어는 사용 불가
3. 숫자로 시작 불가
4. 특수문자는 ‘_’와 ‘$’만 가능

개발자들간의 식별자 컨벤션
1. 클래스 이름의 첫 글자는 항상 대문자, 변수와 메서드는 소문자
2. 자바는 카멜케이스
3. 상수의 이름은 항상 대문자

변수는 기본형과 참조형이 있다

기본형(primitive)는 실제 값을 저장, 참조형은 주소값을 저장

상수는 기본형 변수를 선언 이후 값을 변경할 수 없게 만드는것이며 **final**키워드를 사용한다. 
상수는 1.6버전 이후로부터는 선언시 초기화를 할 필요는 없고 사용하기 전에 하면 된다.

리터럴(literal)
  원래는 12, 123, 3.14, ‘a’와 같은 값들이 ‘상수’인데, 프로그래밍에서는 이미 상수를 ‘값을 한 번 저장하면 변경할 수 없는 저장공간’으로 정의하였기 때문에 이와 구분하기 위해 상수를 다른이름으로 ‘리터럴’으로 사용
즉 리터럴은 상수와 동일한 내용

리터럴 종류

1. 논리형(true, false)
2. 정수형(1, 077, 0xFF, 100L)
3. 실수형(3.14, 1.4f)
4. 문자형(‘a’, ‘1’)
5. 문자열(“abc”, “123”)

실수형에서는 접미사 f(float), d(double)(생략가능)이 존재, 정수형에는 l or L(long)이 존재

배열의 복사는 **System.arraycopy함수**로 처리하기

객체지향이론의 기본 개념은 ‘실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다’ 실제 사물의 속성과 기증을 분석한 다음, 데이터(변수)와 함수로 정의함으로써 실제 세계를 컴퓨터 속에 옮겨 놓은 것과 같은 가상세계를 구현함.

*객체지향이론의 관점*
클래스의 정의: 객체를 정의해 놓은 것
클래스의 용도: 객체를 생성하는데 사용된다.

*프로그래밍적 관점*
클래스: 데이터와 함수의 결합, 사용자정의 타입(user-defined-type)

클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화(instantiate)
어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스(instance)라고 한다.

객체는 속성과 기능으로 이루어져있다.
객체가 가지고 있는 속성과 기능을 그 객체의 멤버(member)라 한다.
여기서 속성은 멤버변수, 기능은 메서드라고 한다.

인스턴스의 생성과 사용
Tv t; // Tv클래스 타입의 참조변수 t를 선언
t = new TV(); // Tv인스턴스를 생성 후 , 생성된 Tv인스턴스의 주소를 t에 저장

클래스의 변수
1. 클래스 변수: 클래스 영역에 선언, 생성은 클래스가 메모리에 올라갈 때
2. 인스턴스 변수: 클래스 영역에 선언, 생성은 인스턴스가 생성되었을 때
3. 지역변수: 클래스 영역 이외의 영역, 변수 선언문이 수행되었을 때

클래스 변수는 static으로 사용되어지고, 모든 인스턴스가 공통된 저장공간을 공유하게 된다. 한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성의 경우, 클래스변수 사용
그리고 클래스 변수는 인스턴스 변수와 다르게, 인스턴스를 생성하지않고도 언제라도 바로 사용할 수 있다.

인스턴스 변수는 인스턴스마다 독립적인 저장공간을 가지므로 서로 다른 값을 가질 수 있다.

자바에서 메서드 호출 시, 매개변수로 지정한 값을 메서드의 메개변수에 복사하여 넘겨준다. 매개변수의 타입이 기본형일 때는 기본형 값이 복사되지만, 참조형이면 인스턴스의 주소가 복사된다. 참조형으로 넘겨지면 값을 읽고, 쓰기까지 가능하다.

클래스 설계
1. 멤버변수 중 모든 인스턴스에 공통적으로 사용해야하는 것에 static사용
2. 클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있다
3. 클래스 메서드는 인스턴스 변수를 사용할 수 없다
4. 1. 인스턴스 멤버는 인스턴스가 반드시 존재해야만 사용할 수 있으므로 클래스 메서드에서 인스턴스 멤버 사용 불가
5. 메서드 내에서 인스턴스 변수를 사용하지 않는다면 static을 붙이는 것을 고려한다.(매개변수로 받아서 처리하면 static사용 좋음)

오버로딩: 한 클래스 내에서 같은 이름의 메서드를 여러개 정의하는 것
장점: 인자가 다른경우에도 함수 이름을 다르게 쓴다면 일일이 다 기억하기 어려운 것을 쉽게 만들어줌

가변인자(variable argument): 매개변수가 동적으로 지정할 수 있게 만들어줌
public void Test(String t1, Object... args)

생성자는 인스턴스가 생성될 때 호출되는 인스턴스 초기화 메서드 이다. 인스턴스 생성 시에 실행되어야 할 작업을 위해서 사용된다.
생성자 역시 메서드처럼 클래스 내에 선언되며, 구조도 메서드와 유사. 리턴값이 없는것이 특징(void)도 사용하지않음
생성자는 오버로딩이 가능(여러 인자에 따라 초기값을 새팅해줄 수 있다)
**연산자 new가 인스턴스를 생성하는 것이지, 생성자가 인스턴스를 생성하지 않는다!!**
단지 생성자는 인스턴스변수들의 초기화에 사용되는 메서드

클래스가 인스턴스를 생성하는 과정(Card c = new Card();)
1. 연산자 new에 의해서 메모리(heap)에 클래스의 인스턴스가 생성
2. 생성자 Card()가 호출되어 수행된다.
3. 연산자 new의 결과로, 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장된다.

자버에서 클래스 내에 생성자가 없을시 기본 생성자를 만들어준다.(만약 다른 생성자가 있다면 만들어주지 않는다)

생성자의 이름으로 클래스이름 대신 this를 사용한다.
한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에만 호출이 가능하다.

this()는 생성자를 호출하는 것이고, this는 인스턴스 자신을 가리키는 참조변수이다. 모든 인스턴스메서드에서 지역변수로 숨겨진 채로 존재(this. 를 통해 인스턴스 멤버에 접근 가능)

멤버변수(클래스변수, 인스턴스변수)와 배열의 초기화는 선택적이지만, 지역변수의 초기화는 필수적이다.

참조형변수의 디폴트값은 null 나머지는 0

클래스 관계
1. 포함(composite)은 클래스 멤버변수에 다른 클래스 인스턴스를 가지는 것

자바는 단일상속만 가능

Object클래스는 모든 클래스의 조상
여기에서 toString, Equals가 정의된 것

오버라이딩은 조상 클래스로 부터 상속받은 메서드의 내용을 변경하는 것
조건은 이름, 매개변수, 반환타입이 다 같아야한다

조상클래스의 메서드를 자손 클래스에서 오버라이딩할 때
1. 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경 불가
2. 예외는 조상 클래스의 매서드보다 많이 선언 불가
3. 인스턴스메서드를 static메서드로 또는 그 반대로 변경 불가

super는 자손 클래스엣 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수.
super에서는 인스턴스변수만 사용할 수 있기 때문에 static메서드에서는 사용 불가.

super()는 조상 클래스의 생성자.

super는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수.
super에서는 인스턴스변수만 사용할 수 있기 때문에 static메서드에서는 사용 불가.

super()는 조상 클래스의 생성자. 상위 조상 클래스의 생성자를 호출하는데 호출의 마지막은 Object클래스의 생성자인 Object()까지 가서야 끝난다. 만약 첫줄에 super()가 없으면 컴파일러가 생성자의 첫줄에 super()를 자동으로 추가한다.

Package와 import

패키지는 클래스의 묶음이다.
클래스 또는 인터페이스를 포함 시킬 수 있으며, 서로 관련된 클래스들끼리 그룹 단위로 묶어 놓음으로써 클래스를 효율적으로 관리할 수 있다.

하나의 소스파일에는 첫 번째 문장으로 단 하나의 패키지 선언만을 허용한다.
모든 클래스는 반드시 하나의 패키지에 속해야한다.
패키지는 점을 구분자로 하여 계층구조로 구성할 수 있다.

만약 패키지를 정의하지 않으면 unnamed package에 속하게 된다.

클래스패스(classpath)는 컴파일러나 JVM 등이 클래스의 위치를 찾는데 사용되는 경로이다.
클래스패스를 지정하지 않으면 기본값은 현재 디렉토리(.)이다.

Import는 다른 패키지의 클래스를 사용할 때 import문으로 명시하면 해당 클래스의 패키지명은 생략할 수 있다. 컴파일러가 컴파일시에 import문을 통해 소스파일에 사용된 클래스의 패키지를 알아내고, 모든 클래스이름 앞에 패키지명을 붙인다.

제어자(modifier)
클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여.
접근제어자(static, protected, default, private)와 그외로 나눠진다.
1. static(클래스의, 공통적인): 인스턴스변수는 하나의 클래스로부터 생성되었더라도 각기 다른 값을 유지하지만, 클래스변수(static)는 인스턴스에 관계없이 같은 값을 같는다. 하나의 변수를 모든 인스턴스가 공유하기 때문. static이 붙은 멤버변수, 메서드 그리고 초기화 블럭은 인스턴스 아닌 클래스에 관계된 것이기 때문에 인스턴스를 생성하지 않고도 사용 가능. / 인스턴스 멤버를 사용하지 않는 메서드는 static을 붙여서 static메서드로 선언하는 것이 더 편리하고 속도도 빠름.
2. final(마지막의, 변경될 수 없는): 변수에 사용하면 변경할 수 없는 상수가 되고, 메서드에 사용하면 오버라이딩을 할 수 없고, 클래스에 사용하면 자신을 확장하는 자손클래스를 정의하지 못한다. final은 주로 선언시나 혹은 생성자에서 초기화를 해준다.
3. abstract(추상의, 미완성의): 추상메서드, 추상클래스를 선언할 때 사용. 추상클래스는 추상메서드가 존재하는 클래스.

접근제어자
1. private: 같은 클래스 내에서만 접근 가능
2. default: 같은 패키지 애에서만 접근 가능
3. protected: 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근 가능.
4. public: 접근 제한 없음

접근제어자를 이용하여 캡슐화를 한다.
1. 외부로부터 데이터를 보호하기 위해서
2. 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서

생성자의 접근 제어자
생성자를 private하여 쓰기도 한다! 이 생성자에서 사용되어지는 방식은 public static getInstance 메서드를 통해서 받아낸다.

다형성(polymorphism)
객체지향개념에서의 다형성: 여러 가지 형태를 가질 수 있는 능력. 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도럭 함으로써 다형성을 프로그램적으로 구현 -> 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 함.
즉 이런 코드가 가능해진다.
Tv와 CaptionTv는 상속관계( Tv -> CaptionTv)
Tv t = new CaptionTv();

그리고
Tv t = new CaptionTv();
CaptionTv c = new CaptionTv();
t와 c는 차이가 있다. 
CaptionTv에서만 있는 메서드나 멤버변수는 c에만 있고, t는 사용할 수 없다.
즉, 참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수조다 같거나 작다.

참조변수 형변환
서로 상속관계에 있는 클래스사이에서만 가능하다.(자바에서는 형제관계는 없다! 그래서 자손과 자손끼리는 형변환 불가!)

자손타입 -> 조상타입(형변환 생략 가능)
조상타입 -> 자손타입(형변환 생략 불가)

형변환은 참조변수의 타입을 변환하는 것! 인스턴스는 단지 사용할 수 있는 멤버의 범위(개수)를 조절하는것뿐!

instanceof 연산자: 검사한 타입으로 형변환이 가능하다는 것!

인스턴스명 instanceof Class명 해당 인스턴스가 클래스 오른쪽에 있는 클래스의 인스턴스면 true리턴.
해당 인스턴스의 조상클래스를 비교하면 true리턴.

조상 클래스와 자손 클래스의 동일한 이름의 멤버변수가 있는 경우 참조변수에 따라서 해당 값을 가져온다. 

추상 클래스(abstract class)

클래스를 설계도에 비유한다면, 추상클래스는 미완성 설계도에 비유할 수 있다. 단지 미완성 메서드(추상메서드)를 포함하고 있다는 의미.
추상클래스로는 인스턴스를 만들 수 없고, 상속을 통해 자손클래스에 의해서만 완성할 수 있다.

추상메서드를 사용하지않고 그냥 빈 함수를 만들어도 되지만, 이러한 abstract를 쓰는 이유는 반드시 자손 클래스에서 구현되어야 하기 때문.

인터페이스(Interface)
일종의 추상클래스. 추상클래스보다 추상화 정도가 높아서 구현부를 가진 일반 메서드와 멤버변수를 구성원으로 가질 수 없다.

인터페이스는 인터페이스로부터 상속 받을 수 있고, 다중상속이 가능하다. 그리고 클래스와 다르게. 최고 조상이 없다(클래스는 Object)

인터페이스의 구현은 클래스에서 implements키워드를 통해 구현. 만약 메서드 중 일부만 구현하면 추상클래스로 선언해야한다. 그리고. 상속과 구현을 동시에 할 수 있다.
class Fighter extends Unit implements Fightable {}

인터페이스도 참조변수로 참조하는 것이 가능.

프로그램 오류는 두가지
1. 컴파일 에러: 컴파일 단계에서 에러
2. 런타임 에러: 실행중에 나는 에러

예외처리
프로그램 실행 시 발생할 수 있는 예기치 못한 예외의 발생에 대비한 코드를 작성하는 것. 목적은 예외의 발생으로 인한 실행중인 프로그램의 갑작스런 비정상 종료를 막는것.

try-catch문에서 흐름

1. 발생한 예외와 일치하는 catch블럭이 있는지 확인
2. 일치하는 catch블럭을 찾게 되면, 그 catch블록 내의 문장들을 수행하고 전체 try-catch문을 빠져나가서 그 다음 문장을 계속해서 수행한다. 만일 일치하는 catch블럭을 찾지 못하면, 예외는 처리되지 못한다.

메서드에 예외 선언하기.
void method() throws Exception1, Exception2 {}

예외 되던지기
예외를 처리하고 해당 메서드를 호출한 메서드에게도 에러를 던지고 싶으면 catch에서 throw를 사용하면 된다.

Object 메서드

1. equals(Object obj) { return this==obj; }
    1. 매개변수로 객체의 참조변수를 받아서 비교하여 그 결과를 리턴.
    2. 두 객체의 같고 다름을 참조변수의 값(주소)으로 판단한다. 즉 서로 다른 객체를 비교하면 항상 false다.
    3. 만약 값을 비교하고싶다면 해당 매서드를 오버라이드 하여 처리한다.
2. hashCode()
    1. 해싱기법에 사용되는 해시함수를 구현한 것.
    2. 찾고자하는 값을 입력하면, 그 값이 저장된 위치를 알려주는 해시코드를 반환한다.
    3. 생성된 객체의 해시코드는 프로그램이 실행될 때마다 할당받은 메모리주소가 다르기에 매번 다르지만, 적어도 프로그램이 시작된 후부터 종료될때까는 같은 값을 유지.
3. toString()
    1. return getClass().getName() + “@“ + Integer.toHexString(hashcode());
    2. 일반적으로 클래스 생성시 toString을 오버라이딩을 하지않으면 위와 같은 값이 리턴된다. 그래서 항상 클래스 생성시 toString을 오버라이딩 하는것이 좋다.
4. clone()
    1. 자신을 복제하여 새로운 인스턴스를 생성하는 일을 한다.
    2. Object클래스의 정의된 clone메서드는 단순히 멤버변수의 값만 복사한다. 그래서 배열같은 경우에는 같은 배열 주소를 가지고 있어서 기존의 인스턴스에 열향을 미친다. 그래서 배열도 완전히 복사하고 싶으면 새로운 배열을 생성하고 배열의 내용을 복사하도록 한다.

String, StringBuffer, Math, Wrapper 생략

내부클래스(inner class)
클래스 내에 선언된 클래스이다.
클래스에 다른 클래스를 선언하는 이유는 두 클래스가 서로 긴밀한 관계에 있기 때문.
두 클래스의 멤버들 간에 서로 쉽게 접근할 수 있다, 그리고 외부에 불필요한 클래스를 감춤으로써 코드의 복잡성을 줄임

종류
1. 인스턴스 클래스: 외부 클래스의 멤버변수 선언위치에 선언, 외부 클래스의 인스턴스멤버터처럼 다뤄짐. 주로 외부 클래스의 인스턴스멤버들과 관련된 작업에 사용될 목적으로 선언
2. 스태틱 클래스: 외부 클래스의 멤버변수 선언위치에 선언, 외부 클래스의 static멤버처럼 다뤄짐. 주로 외부 클래스의 static멤버, 특히 static메서드레서 사용될 목적으로 선언.
3. 지역 클래스: 외부 클래스의 메서드나 초기화 블럭 안에 선언, 선언된 영역 내부에서만 사용 가능
4. 익명 클래스: 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스.

List
인터페이스이다
객체를 일렬로 늘어놓은 구조를 가지구 있다.(저장순서를 유지)
List컬렉션은 객체 자체를 저장하는 것이 아니라 객체의 주소.

1. ArrayList는 안에 배열이 있고 이 배열의 값은 객체의 주소값.
2. Vector는 ArrayList와 동일한 내부구조지만, threadsafe하다.
3. LinkedList

Set
저장순서 유지 X
객체를 중복해서 저장할 수 없음.
하나의 null만 저장 가능
이것은 수학의 집합에 비유될 수 있다.
여기에는 iterator가 있다.
값 자체를 해쉬코드값에 넣는것!!

Map
키를 해시 코드값에 넣는다!


