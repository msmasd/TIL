# Serialization.md

## 간단하게

* Java 내부 시스템에서 사용되는(또는 JVM 메모리에 올려진) 객체나 데이터를 외부에서 사용할 수 있도록 Byte 형태로 변환하는 것(ViceVersa)

## 자세히

* 대부분 OS의 프로세스 구현은 서로 다른 가상메모리주소공간(Virtual Address Space, VAS)를 갖기 때문에 Object 타입의 참조값(주소값)데이터 인스턴스를 전달할 수 없다.(전달해도 서로 다른 메모리 공간에서는 전달된 참조값이 무의미하다.) 때문에 서로 다른 메모리 공간 사이의 데이터 전달을 위해서는 메모리 공간의 주소값이 아닌 Byte 형태로 직렬화(변환)된 객체 데이터를 전달하면, 사용하는 쪽에서 역직렬화하여 사용할 수 있게 된다.
* Java의 클래스 설계에서는 객체 안에 객체가 존재할 수 있다. 객체 A 안에 들어있는 객체는 객체 B를 참조할 수 있는 주소값인데, 직렬화를 하면 이 주소값이 아니라 객체 B 자체의 데이터를 Primitive 타입(Byte 타입) 데이터로 변환한다. 때문에 직렬화 된 데이터는 모두 Primitive 타입(Byte 타입)의 데이터 묶음이며, 이것이 파일 저장이나 네트워크 전송 시 파싱할 수 있는 유의미한 데이터가 되는 것이다. 즉, 전송/저장 가능한 데이터를 만드는 것이 직렬화(Serialization)이다.
* JSON, CSV 등의 포맷은 직렬화/역직렬화 시에 특정 라이브러리를 도입해야 쉽게 개발이 가능하며, 구조가 복잡해지면 직접 매핑해줘야 하지만, Java 직렬화는 비교적 복잡한 객체도 큰 작업 없이 `java.io.Serializable` 인터페이스만 구현해주면 기본 Java 라이브러리만 사용해도 직렬화/역직렬화 가능

## 직렬화의 조건

* `java.io.Serializable` 인터페이스를 상속받은 객체와 Primitive 타입의 데이터가 직렬화의 대상이 될 수 있다.
  * 기본자료형(Primitive Type)은 정해진 Byte의 변수이기 때문에 Byte 단위로 변환하는 것에 문제가 없지만,
  * 객체의 크기는 가변적이며, 객체를 구성하는 자료형들의 종류와 수에 따라 객체의 크기가 다양하게 바뀔 수 있기 때문에 객체를 직렬화하기 위해 Serializable 인터페이스를 구현해야 한다.
* 객체의 멤버들 중 Serializable 인터페이스가 구현되지 않은 것이 존재하면 안된다.
* `Transient`가 선언된 멤버는 전송되지 않는다.
  * 객체 내에 Serializable 인터페이스가 구현되지 않은 멤버 때문에 `NonSerializableException`이 발생하는 경우, Transient를 선언해주면 직렬화 대상에서 제외되기 때문에 문제없이 해당 객체를 직렬화 할 수 있다.

## 직렬화가 사용되는 상황은?

* JVM의 메모리에서 상주하는 객체 데이터를 그대로 영속화(Persistence)할 때 사용된다.
  * 시스템이 종료되더라도 사라지지 않으며, 영속화된 데이터이기 때문에 네트워크로 전송도 가능하다.
* Servlet Session
  * Servlet 기반의 WAS들은 대부분 세션의 Java 직렬화를 지원한다.
  * 파일로 저장, 세션 클러스터링, DB를 저장하는 옵션 등을 선택하면 세션 자체가 직렬화되어 저장 및 전달된다.
* Cache
  * 캐시할 부분을 직렬화된 데이터를 저장해서 사용
* Java RMI(Remote Method Invocation)
  * 원격 시스템에 메서드를 호출할 때 전달하는 메시지(객체)를 직렬화하여 사용
  * 메시지(객체)를 전달받은 원격 시스템에서는 메시지(객체)를 역직렬화하여 사용
* 객체가 세션에 저장하지 않는 단순한 데이터 집합이고, 컨트롤러에서 생성되어 뷰에서 소멸하는 데이터의 전달체라면 객체 직렬화는 고려하지 않아도 된다.
* 세션 관리를 스토리지나 네트워크 자원을 사용한다면 객체 직렬화를 해야 하고, 메모리에서만 관리한다면 객체 직렬화를 할 필요가 없다. 둘다 고려한다면 직렬화가 필요하다.



## 참고
* https://ryan-han.com/post/java/serialization/
