# Richardson Maturity Model(REST의 영광을 향한 단계들)

* 엔터프라이즈가 직면한 많은 통합 문제를 다루기 위해 Restful 웹 서비스를 어떻게 활용할지 설명하는 것.

## Glory of REST

Level 0: The Swamp of POX(Plain Old XML)
Level 1: Resources
Level 2: HTTP Verbs
Level 3: Hypermedia Controls

## Level 0

이 모델의 시작점은 웹 메커니즘을 전혀 사용하지 않고 HTTP를 원격 통신을 위한 전송 시스템으로 사용하는 것이다.
여기에서는 원격 프로시저 호출에 기반한 원격 통신 메커니즘을 위한 터널링 메커니즘으로서 HTTP를 사용하는 것이다.

단지 POX(Plain Old XML)를 주고 받는 단순한 RPC 스타일 시스템에 불과했다.
SOAP이나 XML-RPC를 사용한다 하더라도, XML 메시지를 envelop으로 감싼다는 점을 제외하면 기존적으로 동일한 메커니즘이다.

## Level 1 - Resources

Rest의 영광을 향한 첫 단계는 리소스를 도입하는 것이다.
그래서 이제는 모든 요청을 단일 서비스 엔드포인트로 보내는 것이 아니라, 개별 리소스와 통신한다.

url에 서비스만을 사용하는 것이 아니라 URI를 통해 넣는다.

차이는 누군가 검사 예약과 같은 것을 할 필요가 있다면, 우선 ../slots/1234/appointment 같은 URI를 갖는 에약 리소스를 얻고, 그 리소스로 요청을 보낸다.

객체 지향을 하는 사람에게 이것은 객체 식별자의 개념과 유사하다.
함수를 호출하고 인자들을 넘기는 것이 아니라, 다른 정보를 위해 인자들을 제공하는 특정 객체의 메소드를 호출한다.

## Level 2 - HTTP Verbs

level 0, 1에서는 모든 통신을 HTTP POST 메소드를 사용했지만, 어떤 사람들은 GET을 대신 혹은 추가로 사용한다.
이 레벨에서는 별 차이가 없이 둘 다 HTTP를 통한 터널링 메커니즘으로 사용되고 있다.
레벨 2는 여기에서 벗어나, HTTP 사용법에 가능한 가깝게 HTTP 메소드를 사용한다.

HTTP는 GET을 상태를 크게 변화시키지 않는 안전한 오퍼레이션으로 정의한다.
이것은 GET을 안전하게 어떤 순서로든 얼마든지 호출할 수 있도록 하고, 매번 같은 결과를 얻도록 한다.
이로 인한 중요한 결과는 요청이 라우팅되는 중간의 어느 참여자든 웹을 잘 동작하게 하는 핵심 요소인 캐싱을 할 수 있다는 것이다.
HTTP는 통신 상의 모든 참여자에 의해 사용될 수 있는 캐싱을 지원하는 다양한 방법을 제공한다.
HTTP의 규칙을 준수함으로써 그러한 기능의 장점을 취할 수 있다.

예약을 하기 위해 상태를 변경하는 HTTP메소드인 POST 혹은 PUT이 필요하다.
POST와 PUT을 사용하는 것 사이의 트레이드오프는 내가 여기서 다루고 싶은 것 이상이다.
어떤 사람들이 POST/PUT과 create/update 사이의 관계를 부정확하게 만들고 있음을 지적하고 싶다.
POST와 PUT사이의 선택은 create와 update 사이의 선택과는 다소 다르다.

레벨1과 동일한 POST를 사용할지라도, 원격 서비스가 응답하는 방법에는 상당한 차이가 있다.
문제가 없다면, 서비스는 새 리소스가 있음을 알리는 201 응답코드와 함께 응답한다.

201 응답은 클라이언트가 나중에 그 리소스의 현재 상태를 GET하기 위해 사용할 수 있는 URI를 갖는 location 속성을 포함한다.
또한 응답은 클라이언트의 추가 호출을 줄이기 위해 해당 리소스의 표현을 포함한다.

응답에서 중요한 부분은 무엇인가 잘못되었음을 알리기 위해 HTTP 응답 코드를 사용하는 것이다.
이 경우 409는 다른사람이 호환되지 않는 방식으로 리소스를 이미 업데이트했음을 가리키기 위한 좋은 선택으로 보인다.
200 반환코드를 사용하지만 에러 응답을 포함하는 방식과 달리 레벨2에서는 이처럼 명시적으로 에러 응답을 사용한다.
어떤 코드를 사용할지는 프로토콜 설계자에게 달려있지만, 에러가 발생하면 2xx가 아닌 응답이어야만 한다.
레벨2는 HTTP 메소드와 HTTP 응답 코드의 사용을 도입한다.

여기에 일관성 문제가 발생한다!
REST 옹호자들은 모든 HTTP 메소드의 사용에 대해 말한다.
또한 REST가 웹의 실제적인 성공으로부터 학습을 시도하고 있다고 말함으로써 그들의 접근법을 정당화한다.
하지만 웹은 PUT이나 DELETE를 실무에서 많이 사용하지 않는다.
PUT과 DELETE의 사용이 합당한 이유들이 있지만, 웹의 존재가 그 합당한 이유들 중 하나는 아니다.

웹의 존재에 의해 지지되는 핵심 요소들은 발생한 에러의 종류를 커뮤니케이션하기 위해 상태 코드를 사용하는 것과 함께 안전한 오퍼레이션과 안전하지 않은 오퍼레이션 간의 강한 분리를 제공하는 것이다.

## Level 3 - 하이퍼미디어 컨트롤

HATEOAS(Hypertext As The Engine Of Application State)라는 것을 도입한다.
이것은 예약을 하기 위해 무엇을 해야 할지 알기 위해 어떻게 빈 시간대 목록을 가져올지에 대한 문제를 해결한다.

레벨 2에서 보냈던 GET과 동일한 GET요청으로 시작한다.

응답에서 link라는 새로운 요소가 있다.
이 요소는 각 시간대를 예약하는 방법을 알려주는 URI를 포함한 링크 요소를 가진다.

하이퍼미디어 컨트롤의 요점은 그것들이 다음에 무엇을 할 수 있는지와 그것을 하기 위해 다루어야 할 리소스의 URI를 알려준다는 것이다.
우리가 예약 요청을 어디로 보낼지 알아야 하는 것이 아니라, 응답 내 하이퍼미디어 컨트롤이 우리에게 그것을 어떻게 할지 알려준다.

하이퍼미디어 컨트롤의 한가지 명백한 장점은 서버가 클라이언트에 문제를 일으키지 않고 URI scheme을 변경할 수 있다는 것이다.
클라이언트가 "addTest"링크 URI를 찾는 동안, 서버팀은 최초 진입점을 제외한 모든 URI작업을 할 수 있다.

더 나은 장점으로 클라이언트 개발자가 프로토콜을 탐색할 수 있도록 돕는다.
링크는 클라이언트 개발자에게 다음에 무엇이 가능할지 힌트를 제공한다.
그것은 모든 정보를 제공하지는 않는다. "latest"와 "cancel" 컨트롤 둘 다 같은 URI를 가리키고 있다.
하나는 GET이고, 다른 하나는 DELETE임을 알아낼 필요가 있다.
하지만 적어도 그것은 더 많은 정보를 위해 생각할 것과 프로토콜 문서 내에 유사한 URI를 찾기 위한 시작점을 제공한다.

하이퍼미디어 컨트롤을 표현하는 방법에는 절대적인 표준은 없다. 내가 여기에서 사용한 예제들은 실무에서 REST 권장사항으로 따르는 ATOM(RFC 4287)을 사용했다.
나는 타켓 URI를 위해 uri 속성과 관계의 종류를 기술하기 위해 rel 속성을 가진 <link> 요소를 사용한다.
잘 알려진 리소스 관계의 표현은 간단하다. 예를 들어, 자신을 참조하는 관계는 'self'를 사용한다.
서버의 특정 리소스와의 관계는 전체 URI를 사용한다. ATOM에서 잘 알려진 linkrel을 위한 정의는 IANA의 Link Relation을 사용한다.
이것들은 레벨 3의 restful다움에서 리더로서 일반적으로 보여지는 ATOM에 의한 것으로 제한된다.

## 레벨들의 의미

로이 필딩은 레벨 3이 REST의 선행조건임을 명백히 했다.
저자가 발견한 위 내용의 유용한 점은 restful이 내포하고 있는 기본적인 생각들을 이해하기 위한 좋은 점진적인 방법을 제공한다는 것이다.
그것은 일종의 평가 메커니즘에서 사용되어야만 하는 것이 아니라 개념을 배우기 위한 도구라고 생각한다.
나는 우리가 restful 접근법이 시스템을 통합하기 위한 옳은 방법이라는 것을 정말 확신하기 위해 아직 충분한 예를 가지고 있다고 생각하지 않지만, 나는 그것이 매우 매력적인 접근법이고 대부분의 환경에서 추천할만한 것이라고 생각한다.

* 레벨 1은 큰 서비스 엔드포인트를 복수개의 리소스로 나누는 분할 & 정복을 사용해서 복잡성을 다루는 문제를 처리한다.
* 레벨 2는 불필요한 다양성을 제거하고, 동일한 방식으로 유사한 환경을 처리할 수 있도록 메소드의 표준 집합을 도입한다.
* 레벨 3은 프로토콜을 더 스스로 문서화할 수 있는 방법을 제공함으로써 발견가능성(discoverability)을 도입한다.

## 참고

* 원문 : https://martinfowler.com/articles/richardsonMaturityModel.html
* 번역 : https://jinson.tistory.com/190
