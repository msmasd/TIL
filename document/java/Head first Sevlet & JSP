Head first Servlet & JSP

## 서블릿 생명주기

1. 서블릿 클래스 로딩
2. 서블릿 초기화
3. init 메소드 호출
4. 서비스 메소드 호출
5. destory 메소드 호출

## 배포 서술자

## 웹서버와 웹애플리케이션 그리고 서블릿

웹서버가 사용자로부터 서블릿에 대한 요청을 받으면, 서블릿을 바로 호출하는 것이 아니라, 서블릿을 관리하고 있는 컨테이너에게 이 요청을 넘깁니다. 여기서 컨테이너란 물론 서블릿이 배포(deploy)된 컨테이너. 요청을 넘겨받은 컨테이너는 HTTP Request와 HTTP Response 객체를 만들어, 이를 인자로 서블릿 doPost()나 doGet() 메소드 중 하나를 호출한다.

## 컨테이너가 주는 장점

* 통신 지원: 컨테이너는 서블릿과 웹서버가 바로 통신할 수 있는 손쉬운 방법을 제공합니다. 다시 말하면, 서버와 대화하기 위하여 개발자가 직접 ServerSocket을 만들고, 특정 포트에 리스닝하고, 연결요청이 들어오면 스트림를 생성하는 들 이런 복잡한 일련의 일들을 할 필요가 없다. 컨테이너는 이런 통신 기능을 API로 제공한다.
* 라이프사이클 관리: 컨테이너는 서블릿의 탄생과 죽음을 관리한다. 서블릿 클래스를 로딩하여 인스턴스화하고, 초기화 메소드를 호출하고, 요청이 들어오면 적절한 서블릿 메소드를 호출하는 작업을 컨테이너가 한다. 서블릿이 생명을 다한 순간에는 적절하게 GC를 진행한다. 이런 역활덕분에 서블릿 자원 관리를 고민할 필요가 없다.
* 멀티스레깅 지원: 컨테이너는 요청이 들어올 때마다 새로운 자바 스레드를 하나 만든다. 클라이언트의 요청에 따라 적절한 HTTP 서비스 메소드를 실행하면 그걸로 스레딩 작업른 끝이 난다(스레드가 죽은다는 말입니다). 스레드 안정성에 대하여 개발자가 뭔가 하지 않아도 알아서 서버가 다중 요청에 대한 스레드 생성 및 운영에 개해서 알아서 해준다.
* 선언적인 보안 관리: 컨테이너를 사용하면, 보안에 관련된 내용을 서블릿 또는 자바 클래스 코드 안에 하드코딩(필요한 데이터나 값, 코드 등을 직접 타이핑해서 집어넣는 일) 할 필요가 없다. 컨테이너가 있는 환경이라면 보안관리는 xml 배포 서술자에다가 기록하면 된다.
* JSP 지원

## 배포서술자(Deployment Descriptor)

웹 컨테이너도 서블릿을 배포하려면, 배포 서술자라는 xml파일을 먼더 만들어야 합니다. DD파일에는 서블릿과 JSP를 어떻게 실행하느냐에 관한 많은 정보들이 들어있습니다. 그외 등등 DD를 가지고 할 수 있는 일이 무궁무진하다.

## mvc

MVC패턴을 사용하면, 단순히 비즈니스 로직과 프리젠테이션 로직을 분리하는 것 뿐만이 아니라.. 비즈니스 로직이 프리젠테이션 로직과 별개로 존재할 수 있다는 것을 의미합니다.
즉, 비즈니스 로직과 프리젠테이션 로직 사이에 뭔가 다른 로직을 집어넣을 수도 있으며, 비즈니스 로직이 재사용 가능한 자바 클래스로 독립적으로 존재 가능하다는 말이며, 따라서 뷰가 어떤 것이 되어도 관계없다는 것을 의미한다.

## 서블릿 라이프사이클

서블릿은 오직 하나의 중요한 상태를 가진다.
초기화되어있거나, 아니거나
아닌경우는 초기화되는 중, 소멸되는 중, 존재하지 않음 중 하나이다.

### 서블릿 라이프사이클에 있어 3번의 중요한 순간들

1. init()
    1. 호출되는 시점: 컨테이너는 서블릿 인스턴스를 생성한 다음 init() 메소드를 호출합니다. 이 메소드는 service() 메소드 전에 실행되어야 합니다.
    2. 목적: 클라이언트의 요청을 처리하기 전에 서블릿을 초기화할 기회를 주는 것
    3. 재정의해야하나?: 초기화할 코드가 있다면 init()메소드 재정의를 하면 된다.(디비에 대한 접속, 다른 객체에 서블릿을 등록하는 등)
2. service()
    1. 호출되는 시점: 최초 클라이언트의 요청을 받았을 때, 컨테이너는 새로운 스레드를 생성하거나, 아니면 스레드풀로부터 하나를 가지고 와서 서블릿의 service() 메소드를 호출합니다.
    2. 목적: 클라이언트의 HTTP 메소드를 참조하여 doGet(), doPost()를 호출할지 아니면 다른 메소드를 호출할지 판단
    3. 재정의해야하나요? 아닙니다. 거의 하지 않습니다.
3. doGet(), doPost()
    1. 호출되는 시점: service() 메소드가 클라이언트의 HTTP 메소드를 참조하여 doGet(), doPost()를 호출
    2. 목적: 여기에다가 코딩을 하면 된다. 어떤 웹 애플리케이션이든지, 무엇을 하든지 관계없이 이곳이 바로 그 작업을 하는 곳.
    3. 재정의해야 하나요?: 항상 합니다.

컨테이너는 서블릿 하나에 대한 다수의 요청을 처리하기 위하여 다수의 스레드를 실행하지 다수의 인스턴스를 만들지는 않습니다.

## 서블릿 초기화

생성자의 실행은 서블릿이 “존재하지 않음”상태에서 ‘초기화됨’ 상태로 옮겨감을 의미합니다(클라이언트의 요청에 서비스할 준비가 되었다). 그러나 생성자는 단지 객체를 만드는 것이지 서블릿을 만드는 것이 아닙니다. 서블릿이 되기 위해서는 서블릿적인 것을 내려받아야 한다. 즉, 객체가 서블릿이 된다는 것은, 서블릿에 따라오는 고유한 권한을 가진다는 것을 의미한다.

### 서블릿 객체들?

* ServletConfig 객체
    * 서블릿 당 ServletConfig 객체 하나
    * 서블릿 배포 시 설정된 정보를 서블릿으로 넘겨주기 위한 값
    * ServletContext에 접근하기 위해서 이 객체를 사용
    * 파라미터값은 배포 서술자에서 설정 가능
* ServletContext 객체
    * 웹 애플리케이션 당 하나의 ServletContext(이름을 AppContext라고 해야 합니다)
    * 웹 애플리케이션의 파라미터 정보를 읽어오기 위하여 사용합니다(파라미터 정보는 DD 안에 설정되어 있습니다)
    * 이것은 일정의 애플리케이션용 게시판 같은 것입니다. 여기에다가 메시지(속성이라고 함)를 적어놓으면 애플리케이션의 다른 녀석들이 이를 읽을 수 있습니다.
    * 서버 정보를 파악하기 위하여 사용합니다. 컨테이너의 이름 및 버전, 지원하는 API 버전 등.

요청에 대한 응답을 누가할지 선택할 수 있습니다. 요청을 완전히 다른 URL로 방향을 바꿀 수 있으며(리다이렉트) 아니면 웹 애플리케이션에 있는 다른 컴포넌트(보통 JSP)에게 처리를 위임할 수도 있다(이를 dispatch라고 한다)

리다이렉트는 client, request dispatch는 server에서 일어난다. 
