# MSA Experience

## 1 실제업무에서 보는 단점

### 1.1 모든 부분에서 Polyglot하게 할 수 없다

MSA는 서비스들을 분리하여 개발하기 때문에, Ployglot하게 개발을 할 수 있다. 즉 여러언어를 사용하여 개발을 진행 할 수있다. 하지만 개발 언어가 다양해지면, 전체 시스템은 관리가 복잡해 진다. 빌드환경, 배포환경도 달라져야 한다. 테스트나 모니터링을 위한 툴도 다양해야 하고, 튜닝할 포인트도 각기 다를 것이다. 즉, 언어가 많아질 수록 전문성이 낮아 질 수 밖에 없다. netflex도 jvm언어로 시작을 하고있는거 같다.

#### 1.2 Local Test가 힘들다

모든 기능이 한 프로젝트에 담겨있고, 하나의 DB를 바라보고 있다면, Local 환경에서 테스트하기 쉽다. 하지만 MSA는 여러 서비스가 존재한다. 내가 호출해야하는 서비스가 다양한 경우 이를 모두 local환경에 구축하긴 매우 어렵다. 다른 서비스의 내부 환경을 이해해야 한다는 뜻이기 떄문이다.
주로 내 데이터는 로컬 환경, 다른 서비스는 테스트 환경을 바라보게 한다. 해당 서비스가 내려가있거나, 가끔 데이터가 꼬이는 일이 발생하기도 한다.

#### 1.3 Monolithic 환경에서는 항상 살아있던 다른 서비스 들이 간혹 죽어있다

MSA에서 서비스는 다른 프로세스에서 실행되는 컴포넌트라는 의미이다. 즉, 다른 서비스가 살아있음을 보장 할 수 없다. 다른 서비스를 호출했는데 503상태 코드가 리턴된 경우, 내 서비스에서는 어떻게 반응을 해야 할까 고민을 해야한다(**서킷브레이커 패턴**필요)
그래서 Hystrix같은것을 적용하여 서킷브레이커 패턴을 구현한다.
Hystrix는 죽어있는 서비스에 대해서 circuit을 open해서 요청이 timeout 될 때까지 길게 기다리게 하지 않게 하고, 비즈니스 요구사항에 맞게 fallback 정책을 가져갔다. 같이 503을 리턴하는 경우도 있고, 일시적으로 캐싱된 데이터를 리턴하는 경우도 있다.

#### 1.4 ACID가 보장이 안된다

MSA는 기본적으로 분산환경이다. 모든 서비스가 네트워크 상에 존재한다. 따라서 데이터의 일관성을 보장하기 어렵다. 전체 서비스가 엮이면 @Transactional 어노테이션의 마법이 통하지 않는다. 2PC는 어렵고, 해본적도 없다. 포기하는 편이 마음이 편하다. http로 요청을 보냈는데, 서비스가 죽어있다면 다른 서비스에 데이터 반영하는 것을 포기하고 내꺼만 잘 반영하자는 의미가 아니다. 우리는 이런 문제를 위해 다른 서비스에 CUD를 발생시켜야 하는 경우에 Event Driven Architecture를 적용하고 Eventual Consistency를 달성하고자 노력했다. Rabbitmq를 통해 message를 전달했다. rabbitmq가 qos level 1을 지원하므로 최소 한번은 잔달하는 것을 보장해 준다.
하지만 message 전달이 실패하거나 서비스에서 처리 중 오류가 난 경우 보상작업을 해주거나 별도 비즈니스 흐름을 가져가야 하는 복잡합이 추가로 생겨났다.

#### 1.5 다른 서비스의 모델이 변경되는 것에 영향을 받는다.

내가 가진 데이터를 REST API로 다른 서비스 혹은 UI에 제공한다는 의미는 API를 통해 다른 서비스들과 계약을 맺는 것으로 바라 볼 수 있다. 하지만 소프트웨어 개발이 언제나 그렇듯 요구사항은 변경된다. 즉 데이터가 변경되고 모델이 변경될 수 있다. 많이 하는 실수지만 데이터베이스의 모델이 그대로 REST API의 response로 드러난다. 이 경우 서비스별로 독립적으로 빌드 배포가 가능하다는 이유로 계약을 어기고 변경 후 배포하게 된다. 해당 API를 호출하는 순간 내 서비스 기능과 상관없는 에러를 보게 될 것이다. 특히 개발 중에는 더 빈번히 발생한다. 이를 위해 우리는 **Consumer driven contract test**를 추가하게 되었다.

하지만 contract test는 정말 귀찮다. spring cloud contract의 경우 다른 서비스 소스에 내가 원하는 api의 response를 spec으로 추가해야 하고, 그 서비스에서 spec을 기준으로 verify test를 진행하고, spec을 만족하는 stub server를 만들어 maven에 배포해야 하고, 내 서비스에서는 그 stub server를 maven에서 내려 받아서 contract test를 작성해야 한다. 서비스 팀간에 많은 의사소통이 필요하다.

이런 문제가 있을때 관련해서 많이 언급되는 것이 [Tolerant Reader](https://martinfowler.com/bliki/TolerantReader.html) 패턴 인데, spring에서 서비스간 통신시 jackson을 사용하는 경우 할 수 있는 것이 별로 없다.

하지만 중요한 것은, 내 서비스에서 API를 제공하면서 다른 서비스를 어떻게 바라보느냐이다. DDD context map에서 말하는 customer-supplier 관계로 바라본다면 supplier가 주도하지만 결과적으로 customer에서 원하는 결과를 제공해 줘야 한다. 하지만 다른 서비스를 단순히 준수자(Conformist)로 바라본다면 내가 변경하는 대로 알아서 반응하기를 기대하는 것이다.(예를 들면, naver open api 스펙이 변경되면 사용하는 쪽에서 알아서 변경해야하는 준수자가 되는 것이다.) 사실 변경하는 입장에서 다른 서비스를 준수자로 바라 보는 것이 편하다. 하지만 내 변경으로 인해 전체 시스템이 동작하지 않게 될 수도 있다.

#### 1.6 UI와 Service의 모델이 다르다

UX 디자이너 입장에서는 구현의 복잡함에 관계없이 사용자에게 가장 가치있고 편한 디자인을 해야 했다. 서비스 개발자 입장에서는 의존관계를 잘 분리하고 최대한 단순한 모습으로 소스와 데이터를 관리 해야했다. 하지만 간혹 잘 나눠진 여러 서비스를 호출해서 하나의 응답으로 리턴해야 하는 경우가 있는데, 이 경우 두 가치가 대립하게 된다. 양쪽 다 잘 지켜져야 하는 부분이기 때문에 PM이 중간에서 밸런스를 잘 맞춰가며 의사결정을 해야 할 것이다.
개발팀에서 고민했던 것은 이런 서비스간 합성(aggregation)이 있을 경우, 혹은 모델을 변경해야 하는 경우 중간 mediation layer를 가져가야 하는 가였다. 결론적으로는 서비스 합성은 필요한 서비스의 controller에서 처리했고, 모델 변경은 UI에서 컨버팅하는 로직을 넣는 것으로 개발되었다.
많은 블로그에서 API Gateway의 기능 중 하나로 mediation기능(aggregation, transformation..)을 처리할 수 있다고 나와 있다. 개인적으로는 게이트웨이에서는 단순히 인증이나 라우팅 정도만 처리하고 서비스에 특화된 기능 들은 서비스 내부에서 처리하거나 mediation을 위한 서비스를 별도로 놓는 것이 좋다고 생각한다.

#### 1.7 클라우드 비용이 많이 든다

서비스가 늘어가고, Database, Eureka, Config server 등 컴포넌트가 추가되고, 이 모든것들이 이중화되고, 테스트 환경이 늘어가면서, AWS 비용이 수직상승하게 되었다. B2B 제품들은 사용자수를 늘리고 동시접속 처리를 잘하는 것이 목적이 아니다. 따라서 인스턴스를 늘리는 것처럼 개발을 위해 서버 운영비용에 크게 투자하는 것을 최소화 해야 한다.
AWS를 쓰던 환경에서 Heroku로 옮기거나, 로컬 서버로 내리는 등의 변경이 자주 발생했다. 개발 환경은 처음부터 내부 서버를 이용하는 것이 마음 편할 것 같다. 이런 일이 자주 일어나다 보니 배포 환경 설정을 위해 Ansible을 적용하고 있다고 들었다.

#### 1.8 빛은 생각보다 느리다

AWS는 서울 리전을 사용하고 비용 문제로 DB는 Heroku를 사용한 적이 있는데, Heroku는 한국 리전이 없다. 몇 ms로 처리되던 것들이 몇 초가 걸리는 진귀한 경험을 하게된다. 네트워크가 빛으로 통신한다고 빠르다고 생각하면 정말 큰 오산이다. 만약 서비스간 통신이 바다를 넘나드는 일이 있다면 빠른 인터넷 속도를 경험하며 자라온 한국 사람들에게 있을 수 없는 경험이 될 것이다.

#### 1.9 아키텍트팀의 설정 변경으로 인해 서비스의 소스가 다시 빌드, 배포가 될 때가 있다

나는 우리 서비스의 소스가 개발팀의 변경에 의해서만 재 배포가 되기를 원했다. 아키텍트 팀의 환경설정 변경으로 인해 자주 재빌드 되고 그 과정에서 빌드가 실패하고 이로 인해 실제 기능이 잠시동안 배포되지 못한 일이 있었다. Spring cloud Config server가 도입된 이후 설정 변경으로 빌드가 깨지는 문제는 많이 해결되긴 했지만 알 수 없는 설정이 생기기 시작했다. 또한 서비스의 로직과 상관없이 오류가 발생하기도 했다.
Code ownership이 어디까지 가질 것이냐, Whole team을 어디까지 바라볼 것 인가의 문제였다. 기본적으로 코드의 변경은 서비스 개발 팀으로 한정해야 한다고 생각한다. 빌드가 깨지고 버그가 생기면 조치해야 하는 팀은 서비스 팀이기 때문이다. 서비스팀 밖에서 적용하고자 하는 코드가 있다면 Merge request를 이용했으면 좋겠다.

## 참조

1. [삼성SDS개발자의 블로그](https://kihoonkim.github.io/2018/03/25/Microservices%20Architecture/first-msa-retro/)