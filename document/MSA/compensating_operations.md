# compensating operations(보상 트랜잭션)

상품쪽 서비스에서 상품의 재고를 하나 감소시키는 API를 제공해야하면 이에 대한 보상 트랜잭션으로 상품의 재고를 하나 증가시키는 API를 제공하고, 결제가 실패하는 경우 이 보상 트랜잭션을 호출하라는 것이다.

간단히 하면, API를 두개씩 (혹은 두배로) 만들어야 하니 귀찮기는 해도 MSA로 얻어지는 장점을 생각하면 괜찮은 방법이다.

하지만 실제 구현시에, 보상트랜잭션을 호출하다가 오류가 발생했을 경우에는, 로그를 모아놓고 배치처리를 하거나, 성공할때까지 계속 호출하는 억지스러운 방법을 사용해야할지도 모른다.

하나의 트랜잭션을 묶고 싶은 분산된 서비스간의 보상 트랜잭션을 우아하게 처리하려면 어떻게 해야 하는가?
이렇게 하나로 묶고 싶은 두개의 기능이 꼭 "실시간"으로 동기화 처리 되지 않아도 된다고 하면 "역활과 책임"의 관점에서 썩 괜찮은 방법이 있다.

"역활과 책임"의 관점에서 볼때, 위 예시에서 보면 결제라고 하는 상위 서비스에서 상품이라고 하는 하위 서비스를 사용하고 있는데, 상품의 재고를 늘리고 줄이는 것과 그 과정에서 발생할 수 있는 오류를 적절하게 처리하는 것을 상품 서비스의 역활과 책임이라고 하자.

그럼 "결제"의 입장에서 어떤 방식으로 결제가 성공하거나 실패했을 때 상품의 재고량에 대한 역활과 책임을 상품이 갖게 할 수 있을까?

"결제" 어플리케이션에서는 "결제"에 같이 묶고자 하는 다른 서비스 (재고감소, 포인트 적립 등..) 트랜잭션에 대한 이벤트를 "결제"의 boundary안에 있는 DB에 저장하고(여기까지는 결제트랜잭션과 하나의 트랜잭션으로 묶어야 한다), DB에 저장된 이벤트들을 "상품"서비스에 전달해 주던지, 가져가게 하는 것이다. 이렇게 발생한 하위 이벤트(상품재고, 포인트 적립등)들을 "결제" 서비스의 context안에 저장하는 것까지 "결제"서비스의 역활과 책임으로 보고 저장된 이벤트들을 실제로 처리하는 역활과 책임은 상품이나 결제의 하위 서비스들이 가져가게 하자.

이렇게 "결제" boundary에 쌓이게 되는 이벤트들을 "상품"이 처리하게 하는 방법은 두 가지로 생각해 볼 수 있다. 먼저 "결제"가 "상품"에게 이벤트를 전달하는 방식과 -event forwarder- "상품"이 "결제"로 부터 이벤트를 가져가게 하는 방식 -event dispatcher-으로 생각해 볼 수 있다.

먼저, 첫번째 방식은 "결제"가 "상품"에게 이벤트를 전달하는 방식은 "결제"이벤트가 발생할 때마다 "상품"에게 이벤트를 전달함으로써 실시간에 가깝게 처리될 수 있고 상태관리를 하지 않아도 된다는 장점이 있지만, 앞서 고민했던 "결제"가 "상품"에게 이벤트를 전달하다가 실패하는 경우 "결제"입장에서 어떻게 처리해야 할지 고민이 될 수 밖에 없다.

두번째 방법은 "상품"이 "결제"로부터 주기적으로 이벤트의 목록을 요청해서 받아가는 방식인데, "상품"이 이벤트를 어디까지 처리했는지 상태관리를 할 필요가 있고, 오류가 발생한 경우 재시도 정책등을 "상품"에서 가져갈 수 있다는 장점이 있다. 상태 관리를 할 필요가 있다는 말은 "상품"이 어디까지 이벤트를 처리했는지 알고 있어야 하고, "결제"에 요청할 때는 처리하고자 하는 밤위(인덱스)를 같이 말해줘야 한다.

즉, "14987번 이후에 발생한 모든 이벤트를 주세요" 또는 "5000번 이후에 발생한 이벤트 10개를 주세요"나, 실패한 것을 재처리 할 필요가 있다면 "14876번 이벤트를 주세요"라고 요청할 수 있다.

어떻게 보면 "결제"라는 서비스를 위해 "상품"이라는 서비스가 너무 많은 일을 해야 하는 것이 아닌가라고 생될 수 있지만, "상품"의 재고량에 대한 정확한 정보를 전달 하는 역활과 책임은 "결제"서비스가 아닌 "상품"서비스에 있다고 볼 숭 ㅣㅆ다.

## 참조

1. [보상트랜잭션 블로그]](https://goodyhlee.wordpress.com/tag/%EB%B3%B4%EC%83%81-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/)