# MSA(Micro Service Architecture)

아래 조건들의 서비스들의 집합으로 이루어진 어플리케이션 아키텍쳐 스타일입니다.

* Highly maintainable and testable(높은 가용성과 테스트가능한것)
* Looely coupled(느슨한 결합)
* Independently deployable(독립적으로 배포가능한)
* Organized around business capabilities
* Owned by a small team(작은 팀들이 소유한)

MSA는 복잡하고 큰 어플리케이션을 빠르고, 자주 그리고 신뢰할 수 있게 제공해준다.

단순히 말하면, 단일 응용 프로그램을 나누어 작은 서비스의 조합으로 구축하는 방법이며, 각 개별 서비스는 자신의 프로세스에서 실행하는 HTTP 기반 API등으로 가벼운 연결 방식을 사용합니다. 각 서비스는 비즈니스 로직의 수행 기능에 맞게 구축 된 완전히 자동화 된 머신에 의한 배포를 통해 이루어 집니다. 각 서비스의 최소한의 중앙 관리 기능은 있지만, 서로 다른 프로그래밍 언어에 의해 개발되고, 다른 데이터 저장 기술을 이용할 수 있습니다.

모놀리식 응용 프로그램은 잘 작동하지만 서서히 문제가 발생합니다.
클라우드에 애플리케이션을 점점 많이 배포되는 경우 특히 그렇습니다. 특히, 배포 주기를 늘리는 것이 점점 어려워집니다. 응용 프로그램 내 작은 부분에 대한 변경이 있더라도, 모놀리식 방식은 모드 빌드해서 다시 배포해야 합니다. (**덩어리가 커지면 배포 시간이 길어져 배포에 어려움이 생김**)

시간이 지남에 따라 모듈구조를 문제 없이 유지하는 것은 점점 어려워지고, 각 모듈의 변경 사항을 그 모듈에만 한정하는 것도 힘들어집니다. (**모듈의 레거시화로 인해 레거시 코드 변경의 어려움**)

서버 확장성도 자원을 더 필요로 하는 부분만 아니라 전체 응용 프로그램의 규모에 따라 더 필요해집니다. (**필요한 부분에만 자원을 scaleOut할 수 없는 상황**)

## 1. 특징

### 1.1 서비스를 통한 컴포넌트화

소프트웨어 산업에서는 오랫 동안 구성 요소(Component)를 나누고 이를 연결하는 시스템을 구축해 왔습니다. 최근 10-20년 동안 우리는 대부분의 개발 언어 환경의 공통 라이브러리의 놀라운 발전을 보아 왔습니다. 구성 요소에 대해 논의 할 때, 무엇이 구성 요소를 만드는가 하는 것을 정의하는 것은 어렵습니다. 그래서, 간단하게 우리는 **구성 요소**를 독립적으로 대체하거나 업그레이드 가능한 소프트웨어 단위로 정의하겠습니다.

마이크로서비스 역시 라이브러리를 사용하지만, 각 소프트웨어 자체를 컴포너트화하는 첫 번째 방법은 여러 서비스로 분리하는 것입니다. 우리는 **라이브러리**를 프로그램에 링크되어 메모리 내 함수 호출을 사용하는 구성 요소로 정의합니다. 이것은 **서비스**가 웹 서비스 요청 또는 RPC와 같은 통신 외부 프로세스 구성 요소인 것과는 대조적입니다.(이 정의는 많은 객체 지향 프로그램의 서비스 객체의 개념과는 다른 것입니다.)

(라이브러리가 아닌) 구성 요소로서 서비스를 정의하는 주요 이유 중 하나는 각 서비스가 독립적으로 배치 가능하기 때문입니다. 만일 단일 프로세스 내에 다중 라이브러리에 의해 응용 프로그램을 구성하는 경우, 각 구성 요소의 변경으로 인해 전체 응용 프로그램의 재배포가 필요합니다. 하지만, 응용 프로그램이 여러 서비스에 분해되어 있었을 경우 다수의 서비스가 각각 변경되는 경우에는 해당 서비스의 재배포만 필요합니다. 물론 이것은 절대적인 것이 아니며, 약간의 변화만 있으면 각 서비스 인터페이스도 조금씩 바뀔수 있습니다. 하지만, 결국 마이크로 서비스 아키텍어의 목적에 맞는 적합한 서비스 경계를 만들어서 앞으로 서비스 사이의 약속을 보장하면서 진화해 나갈 것입니다.

컴포넌트로서 서비스를 사용하면 각 구성 요소의 인터페이스가 보다 명시적이 된다는 점도 중요합니다. 대부분의 프로그래밍 언어는 명시적인 공표된 인터페이스를 정의하는데 효과적인 메커니즘을 가지고 있지 않습니다. 클라이언트가 구성 요소 캡슐화를 파괴하는 것을 방지하기 위해서는 기술 문서나 내부 코딩 규칙에 의존해야 하고, 결국 구성 요소 간의 결합도를 지나치게 높이는 결과를 가져옵니다. 각 서비스는 명시적인 원격 호출 메커니즘을 이용하여 이러한 종속과 결합을 방지하는데 도움을 줍니다.

이와 같은 서비스를 만드는데 따른 부정적인 측면도 있습니다. 원격 호출은 프로세스 내부 호출보다 비용이 높기 때문에 원격 API는 각 구성요소를 크게 나누는(coarse-grained) 경향이 있습니다. 사용하기 어려울 뿐만 아니라 만약 구성요소간의 책임 할당을 변경할 필요가 있는 경우, 이러한 변화는 프로세스 경계를 넘는 경우 더욱 힘든 일이 될 것입니다.

### 1.2 비즈니스 수행에 따른 구성

거대한 응용 프로그램을 분할하는 경우에 볼 수 있는 흔한 관리 방식은 기술적 계층에 초점을 맞추어 UI팀, 비즈니스 로직 팀, 그리고 데이터베이스 팀과 같은 편성하는 것입니다. 이러한 사고 방식에 따라 각 팀을 분리할 때, 단순한 변경이 필요한 경우라도 리소스 및 예산 승인에 시간이 걸리고 자칫 많은 팀간 협업을 해야 하는 커다란 프로젝트 규모가 될 수 있습니다. 현명한 팀은 이런 일을 최적화하고 더 나은 방법을 지향합니다. - 즉, 변경이 필요한 응용 프로그램 안에 모두 로직을 넣는 것입니다. 즉, 비즈니스 로직을 어디서나 포함(Logic everywhere)시킵니다. 이것은 Conway의 법칙에 따라 행동 한 예 입니다.

#### Melvyn Conway

(일반적으로 정의되는) 시스템을 설계하는 어떤 조직도 자신의 조직이 가진 커뮤니케이션 구조를 복제하는 아키텍쳐 디자인을 만들어 낸다.

각자 상호 기능형 팀은 각 제품을 구축 및 운용할 책임을 가지고 각 제품은 메시지 버스를 통해 통신하는 여러 독립적인 서비스로 분할되어 있습니다.

물론 거대한 모놀리식 응용 프로그램도 사업 수행 능력에 따라 모듈화 할 수 있습니다. 하지만, 우리는 모놀리식 애플리케이션을 구축하는 거대한 팀을 비즈니스 항목에 따라 분할하도록 권장하고 있습니다. 우리가 주목하고 있는 문제는 회사들이 맥락(context)에 따라 너무 많은 조직을 구축하는 경향이 있다는 것입니다. 만약 우리가 모놀리식 방식이 다수의 모듈 경계를 넘는 경우, 팀의 개별 구성원들의 단기 기억에 의존해야하는 어려움이 있습니다. 또한, 모듈 경계를 이해하기 위해 강제적으로 많은 교육이 필요하다는 것을 경험했습니다. 명시적인 서비스 구성 요소에 의해 분할함으로서 명확한 팀 경계를 유지하는 것이 더 쉽습니다.

#### 1.2.1 마이크로서비스의 크기

마이크로서비스가 유명한 아키텍쳐 스타일이 되었다해도 용어 자체가 서비스의 크기에 초점을 맞추지 않고 "마이크로"라는 단어 때문에 계속 논쟁이 있을 수 밖에 없습니다. 마이크로서비스를 해본 사람들도 그 범위가 넓다는 것을 인정합니다. 가장 큰 큐모는 Amazon에서 밝힌 Two Pizza Team(이상적인 팀의 크기는 피자 두판으로 한끼를 떼울 수 있는 규모) 즉, 12명을 넘지 않는다는 것입니다. 우리가 본 제일 작은 팀은 6개의 서비스를 지원하는 6명의 팀입니다.
서비스별로 12명이 필요한지, 서비스별로 한명만 있으면 되는지 또 다른 의문을 만들어 냅니다. 현재로서는 어떤 팀이라도 마이크로서비스를 가능하게 하면서 더 발전할 수 있는 마인드로 함께 변화하는 것이 중요합니다.

### 1.3 프로젝트가 아니라 제품

우리가 본 대부분의 응용 프로그램 개발 활동은 프로젝트 모델을 사용하고 있습니다. 일단 완성을 목표로 소프트웨어를 배포해야 하는 목적 때문입니다. 프로젝트가 끝나면, 소프트웨어는 운영 조직에 넘겨지고 그 소프트웨어를 구축한 프로젝트 팀은 해산합니다.

마이크로서비스를 해 본 사람들은 이러한 모델을 피하는 대신 각 팀은 제품의 전체 라이프사이클을 책임지는 개념을 좋아합니다. 이러한 발상은 Amazon이 만든 개념인 "자신이 만든 건 자신이 실행(you build, you run it)하라"는 것과 일맥상통하며, 각 개발팀이 자신의 소프트웨어 제품의 전반적인 책임을 지는 것입니다. 이 개념은 매일 매일 개발자들이 배포한 소프트웨어의 실행 형태에 대해 살피면서 일반 사용자와의 접점과 피드백을 늘리는 것입니다. 물론 이는 어느 정도 고객 지원을 해야하는 부담도 함께 안게 됩니다.

제품을 인식하는 방식에서 이러한 고려 사항은 사업 수행 능력에 강하게 결합됩니다. 즉, 소프트웨어를 완성하고자 하는 기능의 집합으로 보기보다 어떻게 소프트웨어가 사용자의 비즈니스를 향상시킬 수 있는가 하는 질문에 관계하기 때문입니다.

동일한 접근이 모놀리식 응용 프로그램에도 채택될 수 있지만, 세분화 된 서비스를 통하면 각 서비스 개발자와 사용자 사이의 밀접한 피드백 관계를 쉽게 구축할 수 있습니다.

### 1.4 똑똑한 엔드 포인트와 더미(Dumb) 파이프

다른 프로세스 간의 통신 구조를 만들 때, 통신 방식 그 자체를 스마트하게 하는데 중요하게 생각하는 제품 개발 접근 방식을 많이 보았습니다. 한 예로 Enterprise Service Bus(ESB)가 있습니다. EBS 제품은 메시지 라우팅, 코레오그래피티(choreography), 변환 그리고 비즈니스 규칙 적용을 위한 정교한 기반을 제공하고 있습니다.

마이크로서비스 커뮤니티는 대체로 그 대안으로 "현명한 엔드 포인트와 바보 파이프라인"방식을 선호합니다. 마이크로서비스에서 빌드 된 응용 프로그램은 가능한 느슨하게(decopled) 만들지만, 응집성을 높히는 것을 목표로합니다. - 각 응용 프로그램은 각자 도메인 로직을 가지고 고전적인 유닉스에 있는 필터보다 더 잘 작동합니다. - 요청을 수신하면, 적절한 로직을 적용하고 응답을 생성합니다. 이는 WS-Choreography 혹은 BPEL, 또는 중앙 집중식 도구에 따른 관리(orchestration)되는 복잡한 프로토콜이 아니라, 간단한 REST 방식 프로토콜에 의해 스스로 제어(choreographed)하는 형태입니다.

가장 일반적으로 사용되는 두 개의 프로토콜은 리소스 API를 이용한 HTTP 요청 응답과 경량 메시지 전달입니다. 전자의 표현은 다음과 같습니다.

> 바로 웹으로 해라! 웹 뒤에 두지 말고.. -Ian Robinson

마이크로서비스를 다루는 팀은 월드 와이드 웹과 Unix의 확장 방식을 기초로 한 원칙과 프로토콜을 사용합니다. 자주 사용되는 자원은 각 개발자 및 운영자의 작은 노력으로 캐싱할 수 있습니다.

두번째 접근 방식은 가벼운 메시지 버스 너머로 메시지 통신을 하는 것입니다. (단지 메시지 라우터로만 작동하는) 더미 방식의 인프라입니다. - RabbitMQ 또는 ZeroMQ같은 간단한 구현은 신뢰성 있는 비동기 패브릭 기능 이상 하지 않습니다. - 똑똑한 기능 처리는 바로 메시지의 생성과 소비를 할 엔드 포인트에 존재합니다. 즉, 서비스에 있습니다.

모놀리스에서는 각 구성 요소를 프로세스에서 실행하고, 구성 요소 간의 통신을 메소드 호출이나 함수 호출에 의해서 이루어집니다. 마이크로서비스로 변경하는 가장 주목할 만한 문제점이 바로 통신 패턴의 변경에 따르는 점입니다. 인메모리의 메소드 호출에서 RPC로 바꾸어 보면 그다지 잘 작동하지 않는 복잡한(chatty)통신이 되어 버립니다. 크게 만들어진 통신 방식 대신 더 세밀한 방식으로 대체해야 합니다.

#### 1.4.1 마이크로서비스와 서비스 지향 구조(SOA)

여기부터 더 정리하자..




## 2. 장점


## 3. 단점

### 3.1 실제업무에서 보는 단점

#### 3.1.1 모든 부분에서 Polyglot하게 할 수 없다

MSA는 서비스들을 분리하여 개발하기 때문에, Ployglot하게 개발을 할 수 있다. 즉 여러언어를 사용하여 개발을 진행 할 수있다. 하지만 개발 언어가 다양해지면, 전체 시스템은 관리가 복잡해 진다. 빌드환경, 배포환경도 달라져야 한다. 테스트나 모니터링을 위한 툴도 다양해야 하고, 튜닝할 포인트도 각기 다를 것이다. 즉, 언어가 많아질 수록 전문성이 낮아 질 수 밖에 없다. netflex도 jvm언어로 시작을 하고있는거 같다.

#### 3.1.2 Local Test가 힘들다

모든 기능이 한 프로젝트에 담겨있고, 하나의 DB를 바라보고 있다면, Local 환경에서 테스트하기 쉽다. 하지만 MSA는 여러 서비스가 존재한다. 내가 호출해야하는 서비스가 다양한 경우 이를 모두 local환경에 구축하긴 매우 어렵다. 다른 서비스의 내부 환경을 이해해야 한다는 뜻이기 떄문이다.
주로 내 데이터는 로컬 환경, 다른 서비스는 테스트 환경을 바라보게 한다. 해당 서비스가 내려가있거나, 가끔 데이터가 꼬이는 일이 발생하기도 한다.

#### 3.1.3 Monolithic 환경에서는 항상 살아있던 다른 서비스 들이 간혹 죽어있다

MSA에서 서비스는 다른 프로세스에서 실행되는 컴포넌트라는 의미이다. 즉, 다른 서비스가 살아있음을 보장 할 수 없다. 다른 서비스를 호출했는데 503상태 코드가 리턴된 경우, 내 서비스에서는 어떻게 반응을 해야 할까 고민을 해야한다(**서킷브레이커 패턴**필요)
그래서 Hystrix같은것을 적용하여 서킷브레이커 패턴을 구현한다.
Hystrix는 죽어있는 서비스에 대해서 circuit을 open해서 요청이 timeout 될 때까지 길게 기다리게 하지 않게 하고, 비즈니스 요구사항에 맞게 fallback 정책을 가져갔다. 같이 503을 리턴하는 경우도 있고, 일시적으로 캐싱된 데이터를 리턴하는 경우도 있다.

#### 3.1.4 ACID가 보장이 안된다

MSA는 기본적으로 분산환경이다. 모든 서비스가 네트워크 상에 존재한다. 따라서 데이터의 일관성을 보장하기 어렵다. 전체 서비스가 엮이면 @Transactional 어노테이션의 마법이 통하지 않는다. 2PC는 어렵고, 해본적도 없다. 포기하는 편이 마음이 편하다. http로 요청을 보냈는데, 서비스가 죽어있다면 다른 서비스에 데이터 반영하는 것을 포기하고 내꺼만 잘 반영하자는 의미가 아니다. 우리는 이런 문제를 위해 다른 서비스에 CUD를 발생시켜야 하는 경우에 Event Driven Architecture를 적용하고 Eventual Consistency를 달성하고자 노력했다. Rabbitmq를 통해 message를 전달했다. rabbitmq가 qos level 1을 지원하므로 최소 한번은 잔달하는 것을 보장해 준다.
하지만 message 전달이 실패하거나 서비스에서 처리 중 오류가 난 경우 보상작업을 해주거나 별도 비즈니스 흐름을 가져가야 하는 복잡합이 추가로 생겨났다.

#### 3.1.5 다른 서비스의 모델이 변경되는 것에 영향을 받는다.

내가 가진 데이터를 REST API로 다른 서비스 혹은 UI에 제공한다는 의미는 API를 통해 다른 서비스들과 계약을 맺는 것으로 바라 볼 수 있다. 하지만 소프트웨어 개발이 언제나 그렇듯 요구사항은 변경된다. 즉 데이터가 변경되고 모델이 변경될 수 있다. 많이 하는 실수지만 데이터베이스의 모델이 그대로 REST API의 response로 드러난다. 이 경우 서비스별로 독립적으로 빌드 배포가 가능하다는 이유로 계약을 어기고 변경 후 배포하게 된다. 해당 API를 호출하는 순간 내 서비스 기능과 상관없는 에러를 보게 될 것이다. 특히 개발 중에는 더 빈번히 발생한다. 이를 위해 우리는 **Consumer driven contract test**를 추가하게 되었다.

하지만 contract test는 정말 귀찮다. spring cloud contract의 경우 다른 서비스 소스에 내가 원하는 api의 response를 spec으로 추가해야 하고, 그 서비스에서 spec을 기준으로 verify test를 진행하고, spec을 만족하는 stub server를 만들어 maven에 배포해야 하고, 내 서비스에서는 그 stub server를 maven에서 내려 받아서 contract test를 작성해야 한다. 서비스 팀간에 많은 의사소통이 필요하다.

이런 문제가 있을때 관련해서 많이 언급되는 것이 [Tolerant Reader](https://martinfowler.com/bliki/TolerantReader.html) 패턴 인데, spring에서 서비스간 통신시 jackson을 사용하는 경우 할 수 있는 것이 별로 없다.

하지만 중요한 것은, 내 서비스에서 API를 제공하면서 다른 서비스를 어떻게 바라보느냐이다. DDD context map에서 말하는 customer-supplier 관계로 바라본다면 supplier가 주도하지만 결과적으로 customer에서 원하는 결과를 제공해 줘야 한다. 하지만 다른 서비스를 단순히 준수자(Conformist)로 바라본다면 내가 변경하는 대로 알아서 반응하기를 기대하는 것이다.(예를 들면, naver open api 스펙이 변경되면 사용하는 쪽에서 알아서 변경해야하는 준수자가 되는 것이다.) 사실 변경하는 입장에서 다른 서비스를 준수자로 바라 보는 것이 편하다. 하지만 내 변경으로 인해 전체 시스템이 동작하지 않게 될 수도 있다.

#### 3.1.6 UI와 Service의 모델이 다르다

UX 디자이너 입장에서는 구현의 복잡함에 관계없이 사용자에게 가장 가치있고 편한 디자인을 해야 했다. 서비스 개발자 입장에서는 의존관계를 잘 분리하고 최대한 단순한 모습으로 소스와 데이터를 관리 해야했다. 하지만 간혹 잘 나눠진 여러 서비스를 호출해서 하나의 응답으로 리턴해야 하는 경우가 있는데, 이 경우 두 가치가 대립하게 된다. 양쪽 다 잘 지켜져야 하는 부분이기 때문에 PM이 중간에서 밸런스를 잘 맞춰가며 의사결정을 해야 할 것이다.
개발팀에서 고민했던 것은 이런 서비스간 합성(aggregation)이 있을 경우, 혹은 모델을 변경해야 하는 경우 중간 mediation layer를 가져가야 하는 가였다. 결론적으로는 서비스 합성은 필요한 서비스의 controller에서 처리했고, 모델 변경은 UI에서 컨버팅하는 로직을 넣는 것으로 개발되었다.
많은 블로그에서 API Gateway의 기능 중 하나로 mediation기능(aggregation, transformation..)을 처리할 수 있다고 나와 있다. 개인적으로는 게이트웨이에서는 단순히 인증이나 라우팅 정도만 처리하고 서비스에 특화된 기능 들은 서비스 내부에서 처리하거나 mediation을 위한 서비스를 별도로 놓는 것이 좋다고 생각한다.

#### 3.1.7 클라우드 비용이 많이 든다

서비스가 늘어가고, Database, Eureka, Config server 등 컴포넌트가 추가되고, 이 모든것들이 이중화되고, 테스트 환경이 늘어가면서, AWS 비용이 수직상승하게 되었다. B2B 제품들은 사용자수를 늘리고 동시접속 처리를 잘하는 것이 목적이 아니다. 따라서 인스턴스를 늘리는 것처럼 개발을 위해 서버 운영비용에 크게 투자하는 것을 최소화 해야 한다.
AWS를 쓰던 환경에서 Heroku로 옮기거나, 로컬 서버로 내리는 등의 변경이 자주 발생했다. 개발 환경은 처음부터 내부 서버를 이용하는 것이 마음 편할 것 같다. 이런 일이 자주 일어나다 보니 배포 환경 설정을 위해 Ansible을 적용하고 있다고 들었다.

#### 3.1.8 빛은 생각보다 느리다.

AWS는 서울 리전을 사용하고 비용 문제로 DB는 Heroku를 사용한 적이 있는데, Heroku는 한국 리전이 없다. 몇 ms로 처리되던 것들이 몇 초가 걸리는 진귀한 경험을 하게된다. 네트워크가 빛으로 통신한다고 빠르다고 생각하면 정말 큰 오산이다. 만약 서비스간 통신이 바다를 넘나드는 일이 있다면 빠른 인터넷 속도를 경험하며 자라온 한국 사람들에게 있을 수 없는 경험이 될 것이다.

#### 3.1.9 아키텍트팀의 설정 변경으로 인해 서비스의 소스가 다시 빌드, 배포가 될 때가 있다.

나는 우리 서비스의 소스가 개발팀의 변경에 의해서만 재 배포가 되기를 원했다. 아키텍트 팀의 환경설정 변경으로 인해 자주 재빌드 되고 그 과정에서 빌드가 실패하고 이로 인해 실제 기능이 잠시동안 배포되지 못한 일이 있었다. Spring cloud Config server가 도입된 이후 설정 변경으로 빌드가 깨지는 문제는 많이 해결되긴 했지만 알 수 없는 설정이 생기기 시작했다. 또한 서비스의 로직과 상관없이 오류가 발생하기도 했다.
Code ownership이 어디까지 가질 것이냐, Whole team을 어디까지 바라볼 것 인가의 문제였다. 기본적으로 코드의 변경은 서비스 개발 팀으로 한정해야 한다고 생각한다. 빌드가 깨지고 버그가 생기면 조치해야 하는 팀은 서비스 팀이기 때문이다. 서비스팀 밖에서 적용하고자 하는 코드가 있다면 Merge request를 이용했으면 좋겠다.

## 참조

1. [마이크로 서비스 홈페이지?](https://microservices.io/)
2. [삼성SDS개발자의 블로그](https://kihoonkim.github.io/2018/03/25/Microservices%20Architecture/first-msa-retro/)
3. [마틴 파울러의 마이크로서비스 글 번역본](http://channy.creation.net/articles/microservices-by-james_lewes-martin_fowler) *아직 내용작성 못함*